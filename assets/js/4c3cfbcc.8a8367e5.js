"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[9556],{3326:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"advanced/key-bindings","title":"Key Bindings and Widgets","description":"JLine provides a powerful system for customizing key bindings and creating widgets. This allows you to tailor the behavior of your command-line interface to meet your specific needs.","source":"@site/docs/advanced/key-bindings.md","sourceDirName":"advanced","slug":"/advanced/key-bindings","permalink":"/docs/advanced/key-bindings","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/key-bindings.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Attributed Strings","permalink":"/docs/advanced/attributed-strings"},"next":{"title":"Custom Widgets","permalink":"/docs/advanced/widgets"}}');var t=r(4848),a=r(8453);const l={sidebar_position:5},d="Key Bindings and Widgets",s={},o=[{value:"Understanding Key Bindings",id:"understanding-key-bindings",level:2},{value:"Key Maps",id:"key-maps",level:2},{value:"Creating Custom Key Bindings",id:"creating-custom-key-bindings",level:2},{value:"Binding to Built-in Widgets",id:"binding-to-built-in-widgets",level:2},{value:"Creating Custom Widgets",id:"creating-custom-widgets",level:2},{value:"Calling Widgets Programmatically",id:"calling-widgets-programmatically",level:2},{value:"Emacs vs. Vi Mode",id:"emacs-vs-vi-mode",level:2},{value:"Key Binding Best Practices",id:"key-binding-best-practices",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"key-bindings-and-widgets",children:"Key Bindings and Widgets"})}),"\n",(0,t.jsx)(n.p,{children:"JLine provides a powerful system for customizing key bindings and creating widgets. This allows you to tailor the behavior of your command-line interface to meet your specific needs."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-key-bindings",children:"Understanding Key Bindings"}),"\n",(0,t.jsx)(n.p,{children:"Key bindings map keyboard input to specific actions or functions (called widgets). JLine's key binding system is inspired by GNU Readline and provides similar functionality."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="KeyBindingBasicsExample.java" showLineNumbers',children:'import org.jline.keymap.Binding;\nimport org.jline.keymap.KeyMap;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.Reference;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class KeyBindingBasicsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // highlight-start\n        // Get the main key map\n        KeyMap<Binding> keyMap = reader.getKeyMaps().get(LineReader.MAIN);\n        \n        // Display some default key bindings\n        terminal.writer().println("Default key bindings:");\n        terminal.writer().println("  Ctrl+A: " + keyMap.getBound(KeyMap.ctrl(\'A\')));\n        terminal.writer().println("  Ctrl+E: " + keyMap.getBound(KeyMap.ctrl(\'E\')));\n        terminal.writer().println("  Ctrl+L: " + keyMap.getBound(KeyMap.ctrl(\'L\')));\n        terminal.writer().println("  Ctrl+R: " + keyMap.getBound(KeyMap.ctrl(\'R\')));\n        terminal.writer().println("  Ctrl+U: " + keyMap.getBound(KeyMap.ctrl(\'U\')));\n        terminal.writer().flush();\n        // highlight-end\n        \n        // Read a line to demonstrate the key bindings\n        terminal.writer().println("\\nType some text (try using the key bindings above):");\n        String line = reader.readLine("prompt> ");\n        terminal.writer().println("You entered: " + line);\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"key-maps",children:"Key Maps"}),"\n",(0,t.jsx)(n.p,{children:"JLine organizes key bindings into key maps, which are collections of bindings for different modes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="KeyMapsExample.java"',children:'import org.jline.keymap.Binding;\nimport org.jline.keymap.KeyMap;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class KeyMapsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // highlight-start\n        // Get all key maps\n        Map<String, KeyMap<Binding>> keyMaps = reader.getKeyMaps();\n        \n        // Display available key maps\n        terminal.writer().println("Available key maps:");\n        for (String name : keyMaps.keySet()) {\n            terminal.writer().println("  " + name);\n        }\n        terminal.writer().flush();\n        // highlight-end\n        \n        // Explain key maps\n        terminal.writer().println("\\nKey map descriptions:");\n        terminal.writer().println("  " + LineReader.MAIN + ": Main key map for normal input mode");\n        terminal.writer().println("  " + LineReader.VIINS + ": Vi input mode");\n        terminal.writer().println("  " + LineReader.VICMD + ": Vi command mode");\n        terminal.writer().println("  " + LineReader.EMACS + ": Emacs mode");\n        terminal.writer().println("  " + LineReader.SEARCH + ": Search mode (Ctrl+R)");\n        terminal.writer().println("  " + LineReader.MENU + ": Menu selection mode");\n        terminal.writer().flush();\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-key-bindings",children:"Creating Custom Key Bindings"}),"\n",(0,t.jsx)(n.p,{children:"You can create custom key bindings to add new functionality or modify existing behavior:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CustomKeyBindingsExample.java" showLineNumbers',children:'import org.jline.keymap.Binding;\nimport org.jline.keymap.KeyMap;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.Reference;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class CustomKeyBindingsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // Get the main key map\n        KeyMap<Binding> keyMap = reader.getKeyMaps().get(LineReader.MAIN);\n        \n        // highlight-start\n        // Bind Ctrl+T to insert the current time\n        keyMap.bind(() -> {\n            // Get the current time\n            String time = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss"));\n            \n            // Insert the time at the current cursor position\n            reader.getBuffer().write(time);\n            return true;\n        }, KeyMap.ctrl(\'T\'));\n        \n        // Bind Alt+C to clear the screen\n        keyMap.bind(() -> {\n            terminal.puts(Capability.clear_screen);\n            reader.callWidget(LineReader.REDRAW_LINE);\n            reader.callWidget(LineReader.REDISPLAY);\n            return true;\n        }, KeyMap.alt(\'C\'));\n        \n        // Bind Alt+U to convert the current word to uppercase\n        keyMap.bind(() -> {\n            // Get the current buffer\n            String buffer = reader.getBuffer().toString();\n            int cursor = reader.getBuffer().cursor();\n            \n            // Find the start and end of the current word\n            int start = buffer.lastIndexOf(\' \', cursor - 1) + 1;\n            int end = buffer.indexOf(\' \', cursor);\n            if (end == -1) end = buffer.length();\n            \n            // Extract the current word\n            String word = buffer.substring(start, end);\n            \n            // Replace with uppercase version\n            reader.getBuffer().cursor(start);\n            reader.getBuffer().delete(end - start);\n            reader.getBuffer().write(word.toUpperCase());\n            \n            return true;\n        }, KeyMap.alt(\'U\'));\n        // highlight-end\n        \n        // Display instructions\n        terminal.writer().println("Custom key bindings:");\n        terminal.writer().println("  Ctrl+T: Insert current time");\n        terminal.writer().println("  Alt+C: Clear screen");\n        terminal.writer().println("  Alt+U: Convert current word to uppercase");\n        terminal.writer().println("\\nType some text and try the custom key bindings:");\n        terminal.writer().flush();\n        \n        // Read lines until "exit" is entered\n        String line;\n        while (!(line = reader.readLine("prompt> ")).equalsIgnoreCase("exit")) {\n            terminal.writer().println("You entered: " + line);\n        }\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"binding-to-built-in-widgets",children:"Binding to Built-in Widgets"}),"\n",(0,t.jsx)(n.p,{children:"JLine provides many built-in widgets that you can bind to keys:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="BuiltinWidgetsExample.java"',children:'import org.jline.keymap.Binding;\nimport org.jline.keymap.KeyMap;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.Reference;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class BuiltinWidgetsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // Get the main key map\n        KeyMap<Binding> keyMap = reader.getKeyMaps().get(LineReader.MAIN);\n        \n        // highlight-start\n        // Bind keys to built-in widgets\n        keyMap.bind(new Reference(LineReader.CLEAR_SCREEN), KeyMap.ctrl(\'L\'));     // Clear screen\n        keyMap.bind(new Reference(LineReader.BACKWARD_KILL_WORD), KeyMap.alt(\'h\')); // Delete word backward\n        keyMap.bind(new Reference(LineReader.KILL_WORD), KeyMap.alt(\'d\'));         // Delete word forward\n        keyMap.bind(new Reference(LineReader.BEGINNING_OF_LINE), KeyMap.ctrl(\'A\')); // Move to beginning of line\n        keyMap.bind(new Reference(LineReader.END_OF_LINE), KeyMap.ctrl(\'E\'));      // Move to end of line\n        keyMap.bind(new Reference(LineReader.UP_HISTORY), KeyMap.ctrl(\'P\'));       // Previous history entry\n        keyMap.bind(new Reference(LineReader.DOWN_HISTORY), KeyMap.ctrl(\'N\'));     // Next history entry\n        keyMap.bind(new Reference(LineReader.BACKWARD_WORD), KeyMap.alt(\'b\'));     // Move backward one word\n        keyMap.bind(new Reference(LineReader.FORWARD_WORD), KeyMap.alt(\'f\'));      // Move forward one word\n        keyMap.bind(new Reference(LineReader.CAPITALIZE_WORD), KeyMap.alt(\'c\'));   // Capitalize word\n        keyMap.bind(new Reference(LineReader.TRANSPOSE_CHARS), KeyMap.ctrl(\'T\'));  // Transpose characters\n        // highlight-end\n        \n        // Display instructions\n        terminal.writer().println("Built-in widgets bound to keys:");\n        terminal.writer().println("  Ctrl+L: Clear screen");\n        terminal.writer().println("  Alt+H: Delete word backward");\n        terminal.writer().println("  Alt+D: Delete word forward");\n        terminal.writer().println("  Ctrl+A: Move to beginning of line");\n        terminal.writer().println("  Ctrl+E: Move to end of line");\n        terminal.writer().println("  Ctrl+P: Previous history entry");\n        terminal.writer().println("  Ctrl+N: Next history entry");\n        terminal.writer().println("  Alt+B: Move backward one word");\n        terminal.writer().println("  Alt+F: Move forward one word");\n        terminal.writer().println("  Alt+C: Capitalize word");\n        terminal.writer().println("  Ctrl+T: Transpose characters");\n        terminal.writer().println("\\nType some text and try the key bindings:");\n        terminal.writer().flush();\n        \n        // Read lines until "exit" is entered\n        String line;\n        while (!(line = reader.readLine("prompt> ")).equalsIgnoreCase("exit")) {\n            terminal.writer().println("You entered: " + line);\n        }\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-widgets",children:"Creating Custom Widgets"}),"\n",(0,t.jsx)(n.p,{children:"You can create custom widgets for more complex functionality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CustomWidgetsExample.java" showLineNumbers',children:'import org.jline.keymap.Binding;\nimport org.jline.keymap.KeyMap;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.Widget;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.util.function.Function;\n\npublic class CustomWidgetsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // highlight-start\n        // Create custom widgets\n        \n        // Widget to insert the current date\n        Widget insertDateWidget = () -> {\n            String date = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE);\n            reader.getBuffer().write(date);\n            return true;\n        };\n        \n        // Widget to duplicate the current line\n        Widget duplicateLineWidget = () -> {\n            String currentLine = reader.getBuffer().toString();\n            reader.getBuffer().write("\\n" + currentLine);\n            return true;\n        };\n        \n        // Widget to reverse the current word\n        Widget reverseWordWidget = () -> {\n            // Get the current buffer\n            String buffer = reader.getBuffer().toString();\n            int cursor = reader.getBuffer().cursor();\n            \n            // Find the start and end of the current word\n            int start = buffer.lastIndexOf(\' \', cursor - 1) + 1;\n            int end = buffer.indexOf(\' \', cursor);\n            if (end == -1) end = buffer.length();\n            \n            // Extract the current word\n            String word = buffer.substring(start, end);\n            \n            // Replace with reversed version\n            reader.getBuffer().cursor(start);\n            reader.getBuffer().delete(end - start);\n            reader.getBuffer().write(new StringBuilder(word).reverse().toString());\n            \n            return true;\n        };\n        \n        // Register the widgets\n        reader.getWidgets().put("insert-date", insertDateWidget);\n        reader.getWidgets().put("duplicate-line", duplicateLineWidget);\n        reader.getWidgets().put("reverse-word", reverseWordWidget);\n        \n        // Bind keys to the widgets\n        KeyMap<Binding> keyMap = reader.getKeyMaps().get(LineReader.MAIN);\n        keyMap.bind(insertDateWidget, KeyMap.alt(\'d\'));\n        keyMap.bind(duplicateLineWidget, KeyMap.alt(\'l\'));\n        keyMap.bind(reverseWordWidget, KeyMap.alt(\'r\'));\n        // highlight-end\n        \n        // Display instructions\n        terminal.writer().println("Custom widgets:");\n        terminal.writer().println("  Alt+D: Insert current date");\n        terminal.writer().println("  Alt+L: Duplicate current line");\n        terminal.writer().println("  Alt+R: Reverse current word");\n        terminal.writer().println("\\nType some text and try the custom widgets:");\n        terminal.writer().flush();\n        \n        // Read lines until "exit" is entered\n        String line;\n        while (!(line = reader.readLine("prompt> ")).equalsIgnoreCase("exit")) {\n            terminal.writer().println("You entered: " + line);\n        }\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"calling-widgets-programmatically",children:"Calling Widgets Programmatically"}),"\n",(0,t.jsxs)(n.p,{children:["You can call widgets programmatically using the ",(0,t.jsx)(n.code,{children:"callWidget"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CallWidgetExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class CallWidgetExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // Display instructions\n        terminal.writer().println("This example demonstrates calling widgets programmatically.");\n        terminal.writer().println("The line will be pre-filled and the cursor positioned.");\n        terminal.writer().println("\\nPress Enter to continue...");\n        terminal.writer().flush();\n        terminal.reader().readLine();\n        \n        // highlight-start\n        // Set up a callback to be called before reading a line\n        reader.setVariable(LineReader.BELL_STYLE, "none");\n        reader.setVariable(LineReader.PRE_READ_LINE, (Function<LineReader, Boolean>) r -> {\n            // Pre-fill the line buffer\n            r.getBuffer().write("This is a pre-filled line");\n            \n            // Move cursor to the beginning of the line\n            r.callWidget(LineReader.BEGINNING_OF_LINE);\n            \n            // Move forward by 5 characters\n            for (int i = 0; i < 5; i++) {\n                r.callWidget(LineReader.FORWARD_CHAR);\n            }\n            \n            return true;\n        });\n        // highlight-end\n        \n        // Read a line\n        String line = reader.readLine("prompt> ");\n        terminal.writer().println("You entered: " + line);\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"emacs-vs-vi-mode",children:"Emacs vs. Vi Mode"}),"\n",(0,t.jsx)(n.p,{children:"JLine supports both Emacs and Vi editing modes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="EditingModesExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class EditingModesExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // highlight-start\n        // Create a line reader with Emacs editing mode (default)\n        LineReader emacsReader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .variable(LineReader.EDITING_MODE, LineReader.EMACS)\n                .build();\n        \n        // Create a line reader with Vi editing mode\n        LineReader viReader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .variable(LineReader.EDITING_MODE, LineReader.VI)\n                .build();\n        // highlight-end\n        \n        // Demonstrate Emacs mode\n        terminal.writer().println("Emacs editing mode:");\n        terminal.writer().println("  Ctrl+A: Beginning of line");\n        terminal.writer().println("  Ctrl+E: End of line");\n        terminal.writer().println("  Ctrl+F: Forward character");\n        terminal.writer().println("  Ctrl+B: Backward character");\n        terminal.writer().println("  Alt+F: Forward word");\n        terminal.writer().println("  Alt+B: Backward word");\n        terminal.writer().println("  Ctrl+K: Kill to end of line");\n        terminal.writer().println("  Ctrl+Y: Yank (paste)");\n        terminal.writer().println("\\nType some text in Emacs mode:");\n        terminal.writer().flush();\n        \n        String line = emacsReader.readLine("emacs> ");\n        terminal.writer().println("You entered: " + line);\n        \n        // Demonstrate Vi mode\n        terminal.writer().println("\\nVi editing mode:");\n        terminal.writer().println("  ESC: Enter command mode");\n        terminal.writer().println("  i: Enter insert mode");\n        terminal.writer().println("  h, j, k, l: Move cursor");\n        terminal.writer().println("  w: Forward word");\n        terminal.writer().println("  b: Backward word");\n        terminal.writer().println("  d: Delete");\n        terminal.writer().println("  y: Yank (copy)");\n        terminal.writer().println("  p: Put (paste)");\n        terminal.writer().println("\\nType some text in Vi mode:");\n        terminal.writer().flush();\n        \n        line = viReader.readLine("vi> ");\n        terminal.writer().println("You entered: " + line);\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"key-binding-best-practices",children:"Key Binding Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"When working with key bindings and widgets, consider these best practices:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Respect Standard Bindings"}),": Try to respect standard key bindings that users are familiar with."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Document Custom Bindings"}),": Clearly document any custom key bindings you add."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Avoid Conflicts"}),": Be careful not to override important key bindings unless you have a good reason."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider Different Terminals"}),": Some key combinations may not work in all terminals."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Group Related Bindings"}),": Use a consistent prefix for related bindings (e.g., Alt+1, Alt+2, etc.)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Test Thoroughly"}),": Test your key bindings in different environments and terminal emulators."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Provide Feedback"}),": Give users feedback when they use key bindings, especially for complex operations."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Make Bindings Discoverable"}),": Provide a way for users to discover available key bindings."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider Accessibility"}),": Ensure your key bindings are accessible to users with disabilities."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Allow Customization"}),": If possible, allow users to customize key bindings to their preferences."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>d});var i=r(6540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);