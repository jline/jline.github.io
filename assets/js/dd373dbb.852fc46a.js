"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[7188],{8453:(t,n,e)=>{e.d(n,{R:()=>l,x:()=>s});var r=e(6540);const i={},a=r.createContext(i);function l(t){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function s(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:l(t.components),r.createElement(a.Provider,{value:n},t.children)}},8622:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"advanced/terminal-attributes","title":"Terminal Attributes and Modes","description":"JLine provides fine-grained control over terminal attributes and modes, allowing you to customize how the terminal behaves. Understanding these attributes is essential for creating sophisticated terminal applications.","source":"@site/docs/advanced/terminal-attributes.md","sourceDirName":"advanced","slug":"/advanced/terminal-attributes","permalink":"/docs/advanced/terminal-attributes","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/terminal-attributes.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Non-Blocking Input","permalink":"/docs/advanced/non-blocking-input"},"next":{"title":"JLine Modules Overview","permalink":"/docs/modules/overview"}}');var i=e(4848),a=e(8453);const l={sidebar_position:4},s="Terminal Attributes and Modes",o={},u=[{value:"Terminal Attributes",id:"terminal-attributes",level:2},{value:"Input Flags",id:"input-flags",level:2},{value:"Output Flags",id:"output-flags",level:2},{value:"Control Characters",id:"control-characters",level:2},{value:"Terminal Modes",id:"terminal-modes",level:2},{value:"Canonical Mode vs. Raw Mode",id:"canonical-mode-vs-raw-mode",level:3},{value:"Mode Comparison",id:"mode-comparison",level:3},{value:"Customizing Terminal Behavior",id:"customizing-terminal-behavior",level:2},{value:"Saving and Restoring Attributes",id:"saving-and-restoring-attributes",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(t){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"terminal-attributes-and-modes",children:"Terminal Attributes and Modes"})}),"\n",(0,i.jsx)(n.p,{children:"JLine provides fine-grained control over terminal attributes and modes, allowing you to customize how the terminal behaves. Understanding these attributes is essential for creating sophisticated terminal applications."}),"\n",(0,i.jsx)(n.h2,{id:"terminal-attributes",children:"Terminal Attributes"}),"\n",(0,i.jsx)(n.p,{children:"Terminal attributes control various aspects of terminal behavior, such as input processing, output processing, and control characters."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="TerminalAttributesExample.java" showLineNumbers',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.InputFlag;\nimport org.jline.terminal.Attributes.OutputFlag;\nimport org.jline.terminal.Attributes.LocalFlag;\nimport org.jline.terminal.Attributes.ControlChar;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class TerminalAttributesExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // highlight-start\n            // Get current terminal attributes\n            Attributes attributes = terminal.getAttributes();\n            // highlight-end\n            \n            // Display current attributes\n            terminal.writer().println("Current terminal attributes:");\n            terminal.writer().println("  ECHO: " + attributes.getInputFlag(InputFlag.ECHO));\n            terminal.writer().println("  ICANON: " + attributes.getInputFlag(InputFlag.ICANON));\n            terminal.writer().println("  ICRNL: " + attributes.getInputFlag(InputFlag.ICRNL));\n            terminal.writer().println("  INLCR: " + attributes.getInputFlag(InputFlag.INLCR));\n            terminal.writer().println("  ISIG: " + attributes.getInputFlag(InputFlag.ISIG));\n            terminal.writer().println("  OPOST: " + attributes.getOutputFlag(OutputFlag.OPOST));\n            terminal.writer().println("  ONLCR: " + attributes.getOutputFlag(OutputFlag.ONLCR));\n            terminal.writer().println("  OCRNL: " + attributes.getOutputFlag(OutputFlag.OCRNL));\n            terminal.writer().println("  IEXTEN: " + attributes.getLocalFlag(LocalFlag.IEXTEN));\n            terminal.writer().println("  VEOF: " + attributes.getControlChar(ControlChar.VEOF));\n            terminal.writer().println("  VERASE: " + attributes.getControlChar(ControlChar.VERASE));\n            terminal.writer().println("  VINTR: " + attributes.getControlChar(ControlChar.VINTR));\n            terminal.writer().println("  VSUSP: " + attributes.getControlChar(ControlChar.VSUSP));\n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"input-flags",children:"Input Flags"}),"\n",(0,i.jsx)(n.p,{children:"Input flags control how input is processed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="InputFlagsExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.InputFlag;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class InputFlagsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Get current attributes\n            Attributes attributes = terminal.getAttributes();\n            \n            // Display current input flags\n            terminal.writer().println("Current input flags:");\n            \n            // highlight-start\n            // Common input flags\n            for (InputFlag flag : new InputFlag[] {\n                    InputFlag.IGNBRK,  // Ignore break condition\n                    InputFlag.BRKINT,  // Map break to interrupt\n                    InputFlag.IGNPAR,  // Ignore parity errors\n                    InputFlag.PARMRK,  // Mark parity errors\n                    InputFlag.INPCK,   // Enable parity check\n                    InputFlag.ISTRIP,  // Strip 8th bit\n                    InputFlag.INLCR,   // Map NL to CR\n                    InputFlag.IGNCR,   // Ignore CR\n                    InputFlag.ICRNL,   // Map CR to NL\n                    InputFlag.IXON,    // Enable XON/XOFF flow control\n                    InputFlag.IXOFF,   // Enable sending XON/XOFF\n                    InputFlag.IXANY,   // Any character restarts output\n                    InputFlag.IMAXBEL, // Ring bell on input queue full\n                    InputFlag.IUCLC,   // Map uppercase to lowercase\n                    InputFlag.ECHO,    // Echo input characters\n                    InputFlag.ECHOE,   // Echo erase character as BS-SP-BS\n                    InputFlag.ECHOK,   // Echo NL after kill character\n                    InputFlag.ECHONL,  // Echo NL\n                    InputFlag.NOFLSH,  // Disable flush after interrupt\n                    InputFlag.TOSTOP,  // Stop background jobs that write to terminal\n                    InputFlag.IEXTEN,  // Enable extended functions\n                    InputFlag.ECHOCTL, // Echo control characters in hat notation\n                    InputFlag.ECHOKE,  // BS-SP-BS entire line on line kill\n                    InputFlag.PENDIN,  // Retype pending input at next read\n                    InputFlag.ICANON,  // Enable canonical mode\n                    InputFlag.ISIG,    // Enable signals\n            }) {\n                try {\n                    boolean value = attributes.getInputFlag(flag);\n                    terminal.writer().println("  " + flag + ": " + value);\n                } catch (Exception e) {\n                    terminal.writer().println("  " + flag + ": unsupported");\n                }\n            }\n            // highlight-end\n            \n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"output-flags",children:"Output Flags"}),"\n",(0,i.jsx)(n.p,{children:"Output flags control how output is processed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="OutputFlagsExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.OutputFlag;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class OutputFlagsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Get current attributes\n            Attributes attributes = terminal.getAttributes();\n            \n            // Display current output flags\n            terminal.writer().println("Current output flags:");\n            \n            // highlight-start\n            // Common output flags\n            for (OutputFlag flag : new OutputFlag[] {\n                    OutputFlag.OPOST,  // Post-process output\n                    OutputFlag.ONLCR,  // Map NL to CR-NL\n                    OutputFlag.OCRNL,  // Map CR to NL\n                    OutputFlag.ONOCR,  // Don\'t output CR at column 0\n                    OutputFlag.ONLRET, // NL performs CR function\n                    OutputFlag.OFILL,  // Use fill characters for delay\n                    OutputFlag.OFDEL,  // Fill is DEL\n                    OutputFlag.NLDLY,  // NL delay\n                    OutputFlag.CRDLY,  // CR delay\n                    OutputFlag.TABDLY, // Tab delay\n                    OutputFlag.BSDLY,  // Backspace delay\n                    OutputFlag.VTDLY,  // Vertical tab delay\n                    OutputFlag.FFDLY,  // Form feed delay\n            }) {\n                try {\n                    int value = attributes.getOutputFlag(flag);\n                    terminal.writer().println("  " + flag + ": " + value);\n                } catch (Exception e) {\n                    terminal.writer().println("  " + flag + ": unsupported");\n                }\n            }\n            // highlight-end\n            \n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"control-characters",children:"Control Characters"}),"\n",(0,i.jsx)(n.p,{children:"Control characters define special characters that have specific functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="ControlCharsExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.ControlChar;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class ControlCharsExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Get current attributes\n            Attributes attributes = terminal.getAttributes();\n            \n            // Display current control characters\n            terminal.writer().println("Current control characters:");\n            \n            // highlight-start\n            // Common control characters\n            for (ControlChar cc : new ControlChar[] {\n                    ControlChar.VEOF,    // EOF character (usually Ctrl-D)\n                    ControlChar.VEOL,    // EOL character\n                    ControlChar.VERASE,  // Erase character (usually Backspace)\n                    ControlChar.VINTR,   // Interrupt character (usually Ctrl-C)\n                    ControlChar.VKILL,   // Kill character (usually Ctrl-U)\n                    ControlChar.VMIN,    // Minimum number of characters for non-canonical read\n                    ControlChar.VQUIT,   // Quit character (usually Ctrl-\\\\)\n                    ControlChar.VSTART,  // Start character (usually Ctrl-Q)\n                    ControlChar.VSTOP,   // Stop character (usually Ctrl-S)\n                    ControlChar.VSUSP,   // Suspend character (usually Ctrl-Z)\n                    ControlChar.VTIME,   // Timeout in deciseconds for non-canonical read\n            }) {\n                try {\n                    int value = attributes.getControlChar(cc);\n                    terminal.writer().println("  " + cc + ": " + value + \n                            (value > 0 ? " (\'" + (char)value + "\')" : ""));\n                } catch (Exception e) {\n                    terminal.writer().println("  " + cc + ": unsupported");\n                }\n            }\n            // highlight-end\n            \n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"terminal-modes",children:"Terminal Modes"}),"\n",(0,i.jsx)(n.p,{children:"JLine supports different terminal modes that affect how input and output are processed."}),"\n",(0,i.jsx)(n.h3,{id:"canonical-mode-vs-raw-mode",children:"Canonical Mode vs. Raw Mode"}),"\n",(0,i.jsx)(n.p,{children:"The most important distinction is between canonical mode and raw mode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="TerminalModesExample.java" showLineNumbers',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.InputFlag;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class TerminalModesExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Save original attributes\n            Attributes originalAttributes = terminal.getAttributes();\n            \n            // Display current mode\n            boolean canonicalMode = originalAttributes.getInputFlag(InputFlag.ICANON);\n            terminal.writer().println("Terminal is currently in " + \n                    (canonicalMode ? "canonical" : "raw") + " mode");\n            terminal.writer().flush();\n            \n            // highlight-start\n            // Switch to raw mode\n            Attributes rawAttributes = new Attributes(originalAttributes);\n            rawAttributes.setInputFlag(InputFlag.ICANON, false); // Disable canonical mode\n            rawAttributes.setInputFlag(InputFlag.ECHO, false);   // Disable echo\n            rawAttributes.setInputFlag(InputFlag.ISIG, false);   // Disable signals\n            rawAttributes.setInputFlag(InputFlag.IEXTEN, false); // Disable extended functions\n            \n            // Set control characters for non-canonical mode\n            rawAttributes.setControlChar(Attributes.ControlChar.VMIN, 1);  // Read at least 1 character\n            rawAttributes.setControlChar(Attributes.ControlChar.VTIME, 0); // No timeout\n            \n            // Apply raw mode attributes\n            terminal.setAttributes(rawAttributes);\n            // highlight-end\n            \n            terminal.writer().println("Switched to raw mode. Press any key to continue...");\n            terminal.writer().flush();\n            \n            // Read a single character\n            int c = terminal.reader().read();\n            \n            // Restore original attributes\n            terminal.setAttributes(originalAttributes);\n            \n            terminal.writer().println("\\nSwitched back to canonical mode");\n            terminal.writer().println("You pressed: " + (char)c + " (ASCII: " + c + ")");\n            terminal.writer().flush();\n            \n            terminal.writer().println("\\nPress Enter to exit...");\n            terminal.writer().flush();\n            terminal.reader().readLine();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"mode-comparison",children:"Mode Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Canonical Mode"}),(0,i.jsx)(n.th,{children:"Raw Mode"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Input Processing"}),(0,i.jsx)(n.td,{children:"Line-buffered (until Enter)"}),(0,i.jsx)(n.td,{children:"Character-by-character"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Special Characters"}),(0,i.jsx)(n.td,{children:"Processed (Ctrl+C, Ctrl+Z, etc.)"}),(0,i.jsx)(n.td,{children:"Not processed (unless configured)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Echoing"}),(0,i.jsx)(n.td,{children:"Enabled by default"}),(0,i.jsx)(n.td,{children:"Disabled by default"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Backspace"}),(0,i.jsx)(n.td,{children:"Processed"}),(0,i.jsx)(n.td,{children:"Not processed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Line Editing"}),(0,i.jsx)(n.td,{children:"Enabled"}),(0,i.jsx)(n.td,{children:"Disabled"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Use Case"}),(0,i.jsx)(n.td,{children:"Command-line interfaces"}),(0,i.jsx)(n.td,{children:"Interactive applications, games"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"customizing-terminal-behavior",children:"Customizing Terminal Behavior"}),"\n",(0,i.jsx)(n.p,{children:"You can customize terminal behavior by modifying attributes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="CustomTerminalBehaviorExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.InputFlag;\nimport org.jline.terminal.Attributes.ControlChar;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class CustomTerminalBehaviorExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Save original attributes\n            Attributes originalAttributes = terminal.getAttributes();\n            \n            // highlight-start\n            // Create custom attributes\n            Attributes customAttributes = new Attributes(originalAttributes);\n            \n            // Customize input behavior\n            customAttributes.setInputFlag(InputFlag.ECHO, true);     // Enable echo\n            customAttributes.setInputFlag(InputFlag.ICANON, true);   // Enable canonical mode\n            customAttributes.setInputFlag(InputFlag.ICRNL, true);    // Map CR to NL\n            \n            // Customize control characters\n            customAttributes.setControlChar(ControlChar.VINTR, 3);   // Set Ctrl+C as interrupt\n            customAttributes.setControlChar(ControlChar.VEOF, 4);    // Set Ctrl+D as EOF\n            customAttributes.setControlChar(ControlChar.VSUSP, 26);  // Set Ctrl+Z as suspend\n            \n            // Apply custom attributes\n            terminal.setAttributes(customAttributes);\n            // highlight-end\n            \n            terminal.writer().println("Terminal configured with custom attributes");\n            terminal.writer().println("Type some text and press Enter (Ctrl+D to exit):");\n            terminal.writer().flush();\n            \n            // Read lines until EOF\n            String line;\n            while ((line = terminal.reader().readLine()) != null) {\n                terminal.writer().println("You typed: " + line);\n                terminal.writer().println("Type another line (Ctrl+D to exit):");\n                terminal.writer().flush();\n            }\n            \n            // Restore original attributes\n            terminal.setAttributes(originalAttributes);\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"saving-and-restoring-attributes",children:"Saving and Restoring Attributes"}),"\n",(0,i.jsx)(n.p,{children:"It's important to save and restore terminal attributes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:'title="SaveRestoreAttributesExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class SaveRestoreAttributesExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // highlight-start\n            // Save original attributes\n            Attributes originalAttributes = terminal.getAttributes();\n            // highlight-end\n            \n            terminal.writer().println("Original terminal attributes saved");\n            terminal.writer().println("Temporarily changing terminal attributes...");\n            terminal.writer().flush();\n            \n            // Change attributes (enter raw mode)\n            terminal.enterRawMode();\n            \n            terminal.writer().println("Terminal is now in raw mode");\n            terminal.writer().println("Press any key to restore original attributes...");\n            terminal.writer().flush();\n            \n            // Wait for a keypress\n            terminal.reader().read();\n            \n            // highlight-start\n            // Restore original attributes\n            terminal.setAttributes(originalAttributes);\n            // highlight-end\n            \n            terminal.writer().println("\\nOriginal terminal attributes restored");\n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"When working with terminal attributes and modes, consider these best practices:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always Save Original Attributes"}),": Save the original terminal attributes before making changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always Restore Attributes"}),": Restore the original attributes before exiting, even in error cases."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use try-finally Blocks"}),": Ensure attributes are restored even if exceptions occur."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Document Mode Changes"}),": Clearly document when your application changes terminal modes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Provide User Feedback"}),": Inform users when the terminal mode changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Check Terminal Capabilities"}),": Not all terminals support all attributes and modes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test on Different Platforms"}),": Terminal behavior can vary across platforms."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Helper Methods"}),": Use helper methods like ",(0,i.jsx)(n.code,{children:"enterRawMode()"})," when available."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Consider User Experience"}),": Choose modes appropriate for your application's user experience."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handle Signals Appropriately"}),": Be careful when disabling signal processing (ISIG flag)."]}),"\n"]}),"\n"]})]})}function d(t={}){const{wrapper:n}={...(0,a.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(c,{...t})}):c(t)}}}]);