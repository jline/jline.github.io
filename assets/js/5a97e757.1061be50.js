"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[8041],{6267:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"advanced/interactive-features","title":"Interactive Features","description":"JLine provides several advanced features that enhance the interactive experience of command-line applications. This guide covers some of the most powerful interactive features: PrintAboveWriter, LineReader#printAbove, Status, and Tailtips.","source":"@site/docs/advanced/interactive-features.md","sourceDirName":"advanced","slug":"/advanced/interactive-features","permalink":"/docs/advanced/interactive-features","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/interactive-features.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Syntax Highlighting","permalink":"/docs/advanced/syntax-highlighting"},"next":{"title":"JLine Modules Overview","permalink":"/docs/modules/overview"}}');var r=t(4848),a=t(8453);const s={sidebar_position:2},l="Interactive Features",d={},o=[{value:"PrintAboveWriter and LineReader#printAbove",id:"printabovewriter-and-linereaderprintabove",level:2},{value:"Using LineReader#printAbove",id:"using-linereaderprintabove",level:3},{value:"Using PrintAboveWriter",id:"using-printabovewriter",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Status Line",id:"status-line",level:2},{value:"Basic Status Usage",id:"basic-status-usage",level:3},{value:"Dynamic Status Updates",id:"dynamic-status-updates",level:3},{value:"Status with Multiple Segments",id:"status-with-multiple-segments",level:3},{value:"Tailtips",id:"tailtips",level:2},{value:"Basic Tailtips Usage",id:"basic-tailtips-usage",level:3},{value:"Command-Specific Tailtips",id:"command-specific-tailtips",level:3},{value:"Dynamic Tailtips Based on Context",id:"dynamic-tailtips-based-on-context",level:3},{value:"Combining Features",id:"combining-features",level:2},{value:"Best Practices",id:"best-practices-1",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"interactive-features",children:"Interactive Features"})}),"\n",(0,r.jsx)(n.p,{children:"JLine provides several advanced features that enhance the interactive experience of command-line applications. This guide covers some of the most powerful interactive features: PrintAboveWriter, LineReader#printAbove, Status, and Tailtips."}),"\n",(0,r.jsx)(n.h2,{id:"printabovewriter-and-linereaderprintabove",children:"PrintAboveWriter and LineReader#printAbove"}),"\n",(0,r.jsx)(n.p,{children:"One of JLine's most powerful features is the ability to print text above the current input line. This is particularly useful for displaying asynchronous information (like notifications or progress updates) without disrupting the user's input."}),"\n",(0,r.jsx)(n.h3,{id:"using-linereaderprintabove",children:"Using LineReader#printAbove"}),"\n",(0,r.jsxs)(n.p,{children:["The simplest way to print above the current line is to use the ",(0,r.jsx)(n.code,{children:"printAbove"})," method of the ",(0,r.jsx)(n.code,{children:"LineReader"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="PrintAboveExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\npublic class PrintAboveExample {\n    public static void main(String[] args) throws Exception {\n        Terminal terminal = TerminalBuilder.builder().build();\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n\n        // Start a background thread to print messages\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    Thread.sleep(1000);\n                    // highlight-next-line\n                    reader.printAbove("Notification #" + i);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        // Read input normally\n        while (true) {\n            String line = reader.readLine("prompt> ");\n            System.out.println("You entered: " + line);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this example, notifications will appear above the input line, and the user can continue typing without interruption."}),"\n",(0,r.jsx)(n.h3,{id:"using-printabovewriter",children:"Using PrintAboveWriter"}),"\n",(0,r.jsxs)(n.p,{children:["For more control, you can use the ",(0,r.jsx)(n.code,{children:"PrintAboveWriter"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="PrintAboveWriterExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.InfoCmp.Capability;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\nimport org.jline.utils.PrintAboveWriter;\n\nimport java.io.PrintWriter;\n\npublic class PrintAboveWriterExample {\n    public static void main(String[] args) throws Exception {\n        Terminal terminal = TerminalBuilder.builder().build();\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n\n        // highlight-start\n        // Create a PrintAboveWriter\n        PrintWriter writer = new PrintAboveWriter(reader.getTerminal(),\n                                                 reader::printAbove);\n        // highlight-end\n\n        // Start a background thread to print messages\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    Thread.sleep(1000);\n\n                    // Create a styled message\n                    AttributedStringBuilder asb = new AttributedStringBuilder();\n                    asb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                       .append("Notification #")\n                       .append(String.valueOf(i))\n                       .style(AttributedStyle.DEFAULT);\n\n                    // Print the message above the current line\n                    writer.println(asb.toAnsi(terminal));\n                    writer.flush();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        // Read input normally\n        while (true) {\n            String line = reader.readLine("prompt> ");\n            System.out.println("You entered: " + line);\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PrintAboveWriter"})," class provides a standard ",(0,r.jsx)(n.code,{children:"PrintWriter"})," interface, making it easy to integrate with existing code that expects a ",(0,r.jsx)(n.code,{children:"PrintWriter"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.p,{children:"When using these features, keep these best practices in mind:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use sparingly"}),": Too many messages can be distracting."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep messages concise"}),": Long messages may wrap and take up too much screen space."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider styling"}),": Use colors and styles to differentiate types of messages."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flush the writer"}),": Always call ",(0,r.jsx)(n.code,{children:"flush()"})," after writing to ensure the message is displayed immediately."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread safety"}),": Access to the terminal should be synchronized if multiple threads are writing to it."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"status-line",children:"Status Line"}),"\n",(0,r.jsx)(n.p,{children:"JLine's Status feature allows you to display persistent status information at the bottom of the terminal. This is useful for showing application state, connection status, or other contextual information."}),"\n",(0,r.jsx)(n.h3,{id:"basic-status-usage",children:"Basic Status Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="StatusExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\nimport org.jline.utils.Status;\n\npublic class StatusExample {\n    public static void main(String[] args) throws Exception {\n        Terminal terminal = TerminalBuilder.builder().build();\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n\n        // Create a Status instance\n        Status status = Status.getStatus(terminal);\n        if (status != null) {\n            // highlight-start\n            // Update the status line\n            status.update(new AttributedStringBuilder()\n                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n                    .append("Connected to server | ")\n                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                    .append("3 tasks running")\n                    .toAttributedString());\n            // highlight-end\n        }\n\n        // Read input normally\n        while (true) {\n            String line = reader.readLine("prompt> ");\n            System.out.println("You entered: " + line);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-status-updates",children:"Dynamic Status Updates"}),"\n",(0,r.jsx)(n.p,{children:"You can update the status line dynamically to reflect changes in your application's state:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Start a background thread to update the status\nnew Thread(() -> {\n    try {\n        int taskCount = 0;\n        while (true) {\n            Thread.sleep(2000);\n            taskCount = (taskCount + 1) % 10;\n\n            if (status != null) {\n                status.update(new AttributedStringBuilder()\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n                        .append("Connected to server | ")\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                        .append(taskCount + " tasks running")\n                        .toAttributedString());\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}).start();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"status-with-multiple-segments",children:"Status with Multiple Segments"}),"\n",(0,r.jsx)(n.p,{children:"You can create a more complex status line with multiple segments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Create a multi-segment status line\nAttributedStringBuilder asb = new AttributedStringBuilder();\n\n// Left-aligned segment\nasb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n   .append("Server: Connected");\n\n// Center segment (with padding)\nint width = terminal.getWidth();\nint leftLen = "Server: Connected".length();\nint rightLen = "Users: 42".length();\nint padding = (width - leftLen - rightLen) / 2;\nfor (int i = 0; i < padding; i++) {\n    asb.append(" ");\n}\n\n// Right-aligned segment\nasb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n   .append("Users: 42");\n\nstatus.update(asb.toAttributedString());\n'})}),"\n",(0,r.jsx)(n.h2,{id:"tailtips",children:"Tailtips"}),"\n",(0,r.jsx)(n.p,{children:"Tailtips provide contextual hints or suggestions that appear after the cursor. They're useful for showing completion possibilities, command syntax, or other helpful information."}),"\n",(0,r.jsx)(n.h3,{id:"basic-tailtips-usage",children:"Basic Tailtips Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="TailtipExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\n\npublic class TailtipExample {\n    public static void main(String[] args) throws Exception {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                // highlight-next-line\n                .variable(LineReader.TAILTIP_ENABLED, true)\n                .build();\n\n        // Read input with tailtips\n        while (true) {\n            // error-start\n            String line = reader.readLine("prompt> ", null,\n                    (String) null, null,\n                    s -> {\n                        // This function provides the tailtip based on current input\n                        if (s.startsWith("help")) {\n                            return new AttributedStringBuilder()\n                                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                                    .append(" [command] - Display help for command")\n                                    .toAttributedString();\n                        } else if (s.startsWith("connect")) {\n                            return new AttributedStringBuilder()\n                                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                                    .append(" <host> <port> - Connect to server")\n                                    .toAttributedString();\n                        }\n                        return null;\n                    });\n            // error-end\n\n            System.out.println("You entered: " + line);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"command-specific-tailtips",children:"Command-Specific Tailtips"}),"\n",(0,r.jsx)(n.p,{children:"You can provide different tailtips based on the command being typed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Map of commands to their syntax help\nMap<String, String> commandHelp = new HashMap<>();\ncommandHelp.put("help", "[command] - Display help for command");\ncommandHelp.put("connect", "<host> <port> - Connect to server");\ncommandHelp.put("disconnect", "- Disconnect from server");\ncommandHelp.put("list", "[pattern] - List available resources");\n\n// Read input with command-specific tailtips\nwhile (true) {\n    String line = reader.readLine("prompt> ", null,\n            (String) null, null,\n            s -> {\n                // Extract the command part\n                String[] parts = s.split("\\\\s+", 2);\n                String cmd = parts[0];\n\n                // Look up help for this command\n                String help = commandHelp.get(cmd);\n                if (help != null) {\n                    return new AttributedStringBuilder()\n                            .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                            .append(" " + help)\n                            .toAttributedString();\n                }\n                return null;\n            });\n\n    System.out.println("You entered: " + line);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-tailtips-based-on-context",children:"Dynamic Tailtips Based on Context"}),"\n",(0,r.jsx)(n.p,{children:"You can provide more sophisticated tailtips based on the current parsing context:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Read input with context-aware tailtips\nwhile (true) {\n    String line = reader.readLine("prompt> ", null,\n            (String) null, null,\n            s -> {\n                try {\n                    // Parse the current line\n                    ParsedLine pl = parser.parse(s, s.length());\n                    String word = pl.word();\n                    List<String> words = pl.words();\n\n                    // Command-specific help based on context\n                    if (words.size() >= 1) {\n                        String cmd = words.get(0);\n\n                        if (cmd.equals("connect")) {\n                            if (words.size() == 1) {\n                                // Just the command\n                                return new AttributedStringBuilder()\n                                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                                        .append(" <host> <port> - Connect to server")\n                                        .toAttributedString();\n                            } else if (words.size() == 2) {\n                                // Command and host\n                                return new AttributedStringBuilder()\n                                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                                        .append(" <port> - Port number to connect to")\n                                        .toAttributedString();\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    // Ignore parsing errors\n                }\n                return null;\n            });\n\n    System.out.println("You entered: " + line);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"combining-features",children:"Combining Features"}),"\n",(0,r.jsx)(n.p,{children:"These features can be combined to create a highly interactive and informative command-line interface:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\nimport org.jline.utils.PrintAboveWriter;\nimport org.jline.utils.Status;\n\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InteractiveExample {\n    public static void main(String[] args) throws Exception {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .variable(LineReader.TAILTIP_ENABLED, true)\n                .build();\n\n        // Set up PrintAboveWriter\n        PrintWriter writer = new PrintAboveWriter(terminal, reader::printAbove);\n\n        // Set up Status\n        Status status = Status.getStatus(terminal);\n        if (status != null) {\n            status.update(new AttributedStringBuilder()\n                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n                    .append("Ready")\n                    .toAttributedString());\n        }\n\n        // Command help for tailtips\n        Map<String, String> commandHelp = new HashMap<>();\n        commandHelp.put("help", "[command] - Display help for command");\n        commandHelp.put("connect", "<host> <port> - Connect to server");\n        commandHelp.put("disconnect", "- Disconnect from server");\n        commandHelp.put("list", "[pattern] - List available resources");\n\n        // Start a background thread for notifications\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    Thread.sleep(3000);\n\n                    // Print notification above\n                    AttributedStringBuilder asb = new AttributedStringBuilder();\n                    asb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                       .append("System notification #")\n                       .append(String.valueOf(i));\n\n                    writer.println(asb.toAnsi(terminal));\n                    writer.flush();\n\n                    // Update status\n                    if (status != null) {\n                        status.update(new AttributedStringBuilder()\n                                .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n                                .append("Notification received: ")\n                                .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                                .append(String.valueOf(i))\n                                .toAttributedString());\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        // Main input loop with tailtips\n        while (true) {\n            String line = reader.readLine("prompt> ", null,\n                    (String) null, null,\n                    s -> {\n                        // Extract the command part\n                        String[] parts = s.split("\\\\s+", 2);\n                        String cmd = parts[0];\n\n                        // Look up help for this command\n                        String help = commandHelp.get(cmd);\n                        if (help != null) {\n                            return new AttributedStringBuilder()\n                                    .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))\n                                    .append(" " + help)\n                                    .toAttributedString();\n                        }\n                        return null;\n                    });\n\n            System.out.println("You entered: " + line);\n\n            // Update status based on command\n            if (status != null) {\n                status.update(new AttributedStringBuilder()\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLUE))\n                        .append("Last command: ")\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW))\n                        .append(line)\n                        .toAttributedString());\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-1",children:"Best Practices"}),"\n",(0,r.jsx)(n.p,{children:"When using these interactive features, keep these guidelines in mind:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency"}),": Use consistent styling and positioning for similar types of information."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clarity"}),": Make sure the information is clear and concise."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Update the status and tailtips only when necessary to avoid performance issues."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accessibility"}),": Don't rely solely on colors for conveying information."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread safety"}),": Synchronize access to shared resources when updating from multiple threads."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These interactive features can significantly enhance the user experience of your command-line application, making it more informative and responsive."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);