"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[3601],{6653:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"advanced/non-blocking-input","title":"Non-Blocking Input","description":"JLine provides support for non-blocking input, allowing you to read user input without blocking the execution of your application. This is particularly useful for applications that need to perform background tasks while still being responsive to user input.","source":"@site/docs/advanced/non-blocking-input.md","sourceDirName":"advanced","slug":"/advanced/non-blocking-input","permalink":"/docs/advanced/non-blocking-input","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/non-blocking-input.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Interactive Features","permalink":"/docs/advanced/interactive-features"},"next":{"title":"Terminal Attributes and Modes","permalink":"/docs/advanced/terminal-attributes"}}');var t=i(4848),a=i(8453);const l={sidebar_position:3},o="Non-Blocking Input",s={},c=[{value:"NonBlockingReader",id:"nonblockingreader",level:2},{value:"Reading with Timeout",id:"reading-with-timeout",level:2},{value:"Combining with LineReader",id:"combining-with-linereader",level:2},{value:"Asynchronous Input Handling",id:"asynchronous-input-handling",level:2},{value:"Raw Mode vs. Cooked Mode",id:"raw-mode-vs-cooked-mode",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"non-blocking-input",children:"Non-Blocking Input"})}),"\n",(0,t.jsx)(e.p,{children:"JLine provides support for non-blocking input, allowing you to read user input without blocking the execution of your application. This is particularly useful for applications that need to perform background tasks while still being responsive to user input."}),"\n",(0,t.jsx)(e.h2,{id:"nonblockingreader",children:"NonBlockingReader"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"NonBlockingReader"})," class is the key component for non-blocking input in JLine:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="NonBlockingReaderExample.java" showLineNumbers',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.NonBlockingReader;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NonBlockingReaderExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        // highlight-start\n        // Get a non-blocking reader\n        NonBlockingReader reader = terminal.reader();\n        // highlight-end\n        \n        terminal.writer().println("Type something (program will exit after 10 seconds):");\n        terminal.writer().flush();\n        \n        // Track start time\n        long startTime = System.currentTimeMillis();\n        \n        // Run for 10 seconds\n        while (System.currentTimeMillis() - startTime < 10000) {\n            try {\n                // highlight-start\n                // Check if input is available\n                if (reader.available() > 0) {\n                    // Read a character (non-blocking)\n                    int c = reader.read();\n                    terminal.writer().println("Read character: " + (char)c);\n                    terminal.writer().flush();\n                }\n                // highlight-end\n                \n                // Simulate background work\n                terminal.writer().print(".");\n                terminal.writer().flush();\n                TimeUnit.MILLISECONDS.sleep(500);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n        \n        terminal.writer().println("\\nTime\'s up!");\n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"reading-with-timeout",children:"Reading with Timeout"}),"\n",(0,t.jsx)(e.p,{children:"You can also read with a timeout, which will block for up to the specified time:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="TimeoutReadExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.NonBlockingReader;\n\nimport java.io.IOException;\n\npublic class TimeoutReadExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        NonBlockingReader reader = terminal.reader();\n        \n        terminal.writer().println("Press any key within 5 seconds:");\n        terminal.writer().flush();\n        \n        try {\n            // highlight-start\n            // Read with a 5-second timeout\n            int c = reader.read(5, TimeUnit.SECONDS);\n            // highlight-end\n            \n            if (c != -1) {\n                terminal.writer().println("You pressed: " + (char)c);\n            } else {\n                terminal.writer().println("Timeout expired!");\n            }\n        } catch (IOException e) {\n            terminal.writer().println("Error reading input: " + e.getMessage());\n        }\n        \n        terminal.close();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"combining-with-linereader",children:"Combining with LineReader"}),"\n",(0,t.jsxs)(e.p,{children:["You can combine non-blocking input with the ",(0,t.jsx)(e.code,{children:"LineReader"})," for more sophisticated input handling:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="NonBlockingLineReaderExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.UserInterruptException;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.NonBlockingReader;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NonBlockingLineReaderExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        LineReader lineReader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n        \n        // Flag to control background task\n        AtomicBoolean running = new AtomicBoolean(true);\n        \n        // Start background task\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.submit(() -> {\n            try {\n                while (running.get()) {\n                    // Simulate background work\n                    terminal.writer().print(".");\n                    terminal.writer().flush();\n                    TimeUnit.SECONDS.sleep(1);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } catch (Exception e) {\n                terminal.writer().println("Error in background task: " + e.getMessage());\n                terminal.writer().flush();\n            }\n        });\n        \n        try {\n            // Main input loop\n            while (running.get()) {\n                try {\n                    // Read a line (this will block)\n                    String line = lineReader.readLine("\\nprompt> ");\n                    \n                    if ("exit".equalsIgnoreCase(line)) {\n                        running.set(false);\n                    } else {\n                        terminal.writer().println("You entered: " + line);\n                        terminal.writer().flush();\n                    }\n                } catch (UserInterruptException e) {\n                    // Ctrl+C pressed\n                    running.set(false);\n                }\n            }\n        } finally {\n            // Shutdown background task\n            executor.shutdownNow();\n            try {\n                executor.awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            terminal.writer().println("\\nExiting...");\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"asynchronous-input-handling",children:"Asynchronous Input Handling"}),"\n",(0,t.jsx)(e.p,{children:"For more complex scenarios, you can set up asynchronous input handling:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="AsyncInputExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.NonBlockingReader;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class AsyncInputExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        NonBlockingReader reader = terminal.reader();\n        \n        // Flag to control input handling\n        AtomicBoolean running = new AtomicBoolean(true);\n        \n        // Start input handling thread\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.submit(() -> {\n            try {\n                // highlight-start\n                // Continuously read input\n                while (running.get()) {\n                    int c = reader.read(100);\n                    if (c != -1) {\n                        // Process the input\n                        terminal.writer().println("\\nReceived input: " + (char)c);\n                        \n                        if (c == \'q\' || c == \'Q\') {\n                            running.set(false);\n                        }\n                        \n                        terminal.writer().flush();\n                    }\n                }\n                // highlight-end\n            } catch (IOException e) {\n                if (running.get()) {\n                    terminal.writer().println("Error reading input: " + e.getMessage());\n                    terminal.writer().flush();\n                }\n            }\n        });\n        \n        // Main application loop\n        try {\n            terminal.writer().println("Press keys (q to quit):");\n            terminal.writer().flush();\n            \n            int count = 0;\n            while (running.get() && count < 30) {\n                // Simulate application work\n                terminal.writer().print(".");\n                terminal.writer().flush();\n                \n                TimeUnit.MILLISECONDS.sleep(500);\n                count++;\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            // Shutdown input handling\n            running.set(false);\n            executor.shutdownNow();\n            try {\n                executor.awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            \n            terminal.writer().println("\\nExiting...");\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"raw-mode-vs-cooked-mode",children:"Raw Mode vs. Cooked Mode"}),"\n",(0,t.jsx)(e.p,{children:"Understanding terminal modes is important for non-blocking input:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cooked Mode (Default)"}),": Input is buffered until Enter is pressed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Raw Mode"}),": Input is made available immediately, without buffering"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="RawModeExample.java"',children:'import org.jline.terminal.Attributes;\nimport org.jline.terminal.Attributes.InputFlag;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.NonBlockingReader;\n\nimport java.io.IOException;\n\npublic class RawModeExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Save original terminal attributes\n            Attributes originalAttributes = terminal.getAttributes();\n            \n            // highlight-start\n            // Configure raw mode\n            Attributes rawAttributes = new Attributes(originalAttributes);\n            rawAttributes.setInputFlag(InputFlag.ICANON, false);  // Disable canonical mode\n            rawAttributes.setInputFlag(InputFlag.ECHO, false);    // Disable echo\n            rawAttributes.setControlChar(Attributes.ControlChar.VMIN, 0);  // Non-blocking\n            rawAttributes.setControlChar(Attributes.ControlChar.VTIME, 0); // No timeout\n            \n            // Enter raw mode\n            terminal.setAttributes(rawAttributes);\n            // highlight-end\n            \n            terminal.writer().println("Terminal is in raw mode. Press keys (q to quit):");\n            terminal.writer().flush();\n            \n            NonBlockingReader reader = terminal.reader();\n            \n            // Read characters until \'q\' is pressed\n            while (true) {\n                int c = reader.read(100);\n                if (c != -1) {\n                    terminal.writer().println("Read: " + (char)c + " (ASCII: " + c + ")");\n                    terminal.writer().flush();\n                    \n                    if (c == \'q\' || c == \'Q\') {\n                        break;\n                    }\n                }\n            }\n            \n            // Restore original terminal attributes\n            terminal.setAttributes(originalAttributes);\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(e.p,{children:"When working with non-blocking input in JLine, consider these best practices:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Handle Interruptions"}),": Always handle interruptions properly to ensure clean shutdown."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use Separate Threads"}),": Keep input handling in a separate thread from your main application logic."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Set Appropriate Timeouts"}),": Choose timeout values that balance responsiveness with CPU usage."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Restore Terminal State"}),": Always restore the terminal to its original state before exiting."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Check for EOF"}),": Check for end-of-file conditions (-1 return value) when reading."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use Atomic Flags"}),": Use atomic boolean flags for thread coordination."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Provide User Feedback"}),": Keep users informed about what's happening, especially during long operations."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Graceful Shutdown"}),": Implement graceful shutdown procedures for all threads."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Error Handling"}),": Implement robust error handling for I/O exceptions."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Test on Different Platforms"}),": Test your non-blocking input handling on different platforms and terminal types."]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function l(n){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);