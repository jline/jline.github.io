"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[9131],{5675:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"modules/terminal-providers","title":"Terminal Providers","description":"JLine uses a provider architecture to support different terminal implementations across various platforms. This modular approach allows JLine to work in different environments and adapt to the capabilities of the underlying system.","source":"@site/docs/modules/terminal-providers.md","sourceDirName":"modules","slug":"/modules/terminal-providers","permalink":"/docs/modules/terminal-providers","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/modules/terminal-providers.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"JLine Console UI","permalink":"/docs/modules/console-ui"},"next":{"title":"API Overview","permalink":"/docs/api/overview"}}');var l=i(4848),a=i(8453);const t={sidebar_position:6},s="Terminal Providers",d={},o=[{value:"Provider Architecture",id:"provider-architecture",level:2},{value:"Maven Dependencies",id:"maven-dependencies",level:2},{value:"Provider Comparison",id:"provider-comparison",level:2},{value:"Provider Selection",id:"provider-selection",level:2},{value:"Provider Selection Methods",id:"provider-selection-methods",level:3},{value:"JLine Terminal-JNA",id:"jline-terminal-jna",level:2},{value:"Features",id:"features",level:3},{value:"Usage",id:"usage",level:3},{value:"JLine Terminal-Jansi",id:"jline-terminal-jansi",level:2},{value:"Features",id:"features-1",level:3},{value:"Usage",id:"usage-1",level:3},{value:"JLine Terminal-FFM",id:"jline-terminal-ffm",level:2},{value:"Features",id:"features-2",level:3},{value:"Usage",id:"usage-2",level:3},{value:"JLine Terminal-JNI",id:"jline-terminal-jni",level:2},{value:"Features",id:"features-3",level:3},{value:"Usage",id:"usage-3",level:3},{value:"Exec Terminal Provider",id:"exec-terminal-provider",level:2},{value:"Features",id:"features-4",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Usage",id:"usage-4",level:3},{value:"Dumb Terminal",id:"dumb-terminal",level:2},{value:"Features",id:"features-5",level:3},{value:"Limitations",id:"limitations-1",level:3},{value:"Usage",id:"usage-5",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Unable to create a system terminal",id:"unable-to-create-a-system-terminal",level:4},{value:"JNA/Jansi not found",id:"jnajansi-not-found",level:4},{value:"Illegal reflective access warnings",id:"illegal-reflective-access-warnings",level:4},{value:"Terminal size issues",id:"terminal-size-issues",level:4}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"terminal-providers",children:"Terminal Providers"})}),"\n",(0,l.jsx)(n.p,{children:"JLine uses a provider architecture to support different terminal implementations across various platforms. This modular approach allows JLine to work in different environments and adapt to the capabilities of the underlying system."}),"\n",(0,l.jsx)(n.h2,{id:"provider-architecture",children:"Provider Architecture"}),"\n",(0,l.jsx)(n.p,{children:"JLine's terminal functionality is implemented through a set of provider modules, each using different technologies to interact with the terminal:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"JNI (Java Native Interface)"}),": Direct native code integration"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"JNA (Java Native Access)"}),": Dynamic access to native libraries"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Jansi"}),": Cross-platform ANSI support library"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"FFM (Foreign Function & Memory API)"}),": Modern Java API for native interoperability"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Exec"}),": Fallback using external processes"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Each provider has its own strengths and limitations, and JLine will automatically select the most appropriate provider based on the available dependencies and platform."}),"\n",(0,l.jsx)(n.h2,{id:"maven-dependencies",children:"Maven Dependencies"}),"\n",(0,l.jsx)(n.p,{children:"To use the terminal providers, add the appropriate dependencies to your project:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Core terminal module (required) --\x3e\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal</artifactId>\n    <version>3.29.0</version>\n</dependency>\n\n\x3c!-- Terminal providers (choose one or more) --\x3e\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-jansi</artifactId>\n    <version>3.29.0</version>\n</dependency>\n\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-jna</artifactId>\n    <version>3.29.0</version>\n</dependency>\n\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-jni</artifactId>\n    <version>3.29.0</version>\n</dependency>\n\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-ffm</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,l.jsx)(n.h2,{id:"provider-comparison",children:"Provider Comparison"}),"\n",(0,l.jsx)(n.p,{children:"Here's a comparison of the different terminal providers:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Provider"}),(0,l.jsx)(n.th,{children:"Technology"}),(0,l.jsx)(n.th,{children:"Platforms"}),(0,l.jsx)(n.th,{children:"Advantages"}),(0,l.jsx)(n.th,{children:"Limitations"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"JNI"}),(0,l.jsx)(n.td,{children:"Java Native Interface"}),(0,l.jsx)(n.td,{children:"All"}),(0,l.jsx)(n.td,{children:"Fast, direct access to native functions"}),(0,l.jsx)(n.td,{children:"Requires platform-specific compilation"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"JNA"}),(0,l.jsx)(n.td,{children:"Java Native Access"}),(0,l.jsx)(n.td,{children:"All"}),(0,l.jsx)(n.td,{children:"Dynamic loading of native libraries, no compilation needed"}),(0,l.jsx)(n.td,{children:"Slightly slower than JNI"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Jansi"}),(0,l.jsx)(n.td,{children:"JNI-based library"}),(0,l.jsx)(n.td,{children:"All, focus on Windows"}),(0,l.jsx)(n.td,{children:"Good Windows support, ANSI emulation"}),(0,l.jsx)(n.td,{children:"Additional dependency"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"FFM"}),(0,l.jsx)(n.td,{children:"Foreign Function & Memory API"}),(0,l.jsx)(n.td,{children:"All"}),(0,l.jsx)(n.td,{children:"Modern API, part of Java standard"}),(0,l.jsx)(n.td,{children:"Requires Java 22+"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Exec"}),(0,l.jsx)(n.td,{children:"External processes"}),(0,l.jsx)(n.td,{children:"All"}),(0,l.jsx)(n.td,{children:"Works without native libraries"}),(0,l.jsx)(n.td,{children:"Limited functionality, slower"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"provider-selection",children:"Provider Selection"}),"\n",(0,l.jsx)(n.p,{children:"JLine uses a discovery mechanism to find and select the appropriate terminal provider. The selection process follows this order:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Check for explicitly specified provider via system property or builder method"}),"\n",(0,l.jsx)(n.li,{children:"Try FFM provider if running on Java 22+"}),"\n",(0,l.jsx)(n.li,{children:"Try JNI provider"}),"\n",(0,l.jsx)(n.li,{children:"Try JNA provider if JNA is available"}),"\n",(0,l.jsx)(n.li,{children:"Try Jansi provider if Jansi is available"}),"\n",(0,l.jsx)(n.li,{children:"Fall back to Exec provider"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"provider-selection-methods",children:"Provider Selection Methods"}),"\n",(0,l.jsx)(n.p,{children:"There are two ways to influence provider selection:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.strong,{children:["Using the ",(0,l.jsx)(n.code,{children:"provider()"})," method"]}),": This explicitly selects a specific provider"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:'TerminalBuilder.builder().provider("jansi").build();\n'})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Using boolean methods"}),": These methods enable or disable specific providers but don't explicitly select them"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"// Enable Jansi provider (doesn't select it, just makes it available for selection)\nTerminalBuilder.builder().jansi(true).build();\n\n// Disable Jansi provider\nTerminalBuilder.builder().jansi(false).build();\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["To explicitly select a provider, always use the ",(0,l.jsx)(n.code,{children:"provider()"})," method."]}),"\n",(0,l.jsx)(n.p,{children:"You can explicitly specify which provider to use:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="ProviderSelectionExample.java" showLineNumbers',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class ProviderSelectionExample {\n    public static void main(String[] args) throws IOException {\n        // Let JLine automatically select the best provider\n        Terminal autoTerminal = TerminalBuilder.builder()\n                .system(true)\n                .build();\n        System.out.println("Auto-selected provider: " + autoTerminal.getClass().getSimpleName());\n\n        // highlight-start\n        // Explicitly specify the JNA provider\n        Terminal jnaTerminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("jna")  // Explicitly select JNA provider\n                .build();\n        System.out.println("JNA provider: " + jnaTerminal.getClass().getSimpleName());\n\n        // Explicitly specify the Jansi provider\n        Terminal jansiTerminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("jansi")  // Explicitly select Jansi provider\n                .build();\n        System.out.println("Jansi provider: " + jansiTerminal.getClass().getSimpleName());\n        // highlight-end\n\n        // Close the terminals\n        autoTerminal.close();\n        jnaTerminal.close();\n        jansiTerminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"You can also specify the provider using system properties:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# Use the JNA provider\njava -Dorg.jline.terminal.provider=jna -jar myapp.jar\n\n# Use the Jansi provider\njava -Dorg.jline.terminal.provider=jansi -jar myapp.jar\n\n# Use the FFM provider\njava -Dorg.jline.terminal.provider=ffm -jar myapp.jar\n\n# Use the JNI provider\njava -Dorg.jline.terminal.provider=jni -jar myapp.jar\n\n# Use the Exec provider\njava -Dorg.jline.terminal.provider=exec -jar myapp.jar\n"})}),"\n",(0,l.jsx)(n.h2,{id:"jline-terminal-jna",children:"JLine Terminal-JNA"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"jline-terminal-jna"})," module provides terminal implementations using the Java Native Access (JNA) library. JNA allows Java code to access native shared libraries without writing JNI code."]}),"\n",(0,l.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Dynamic loading of native libraries"}),"\n",(0,l.jsx)(n.li,{children:"No need for platform-specific compilation"}),"\n",(0,l.jsx)(n.li,{children:"Works on Windows, Linux, macOS, and other Unix-like systems"}),"\n",(0,l.jsx)(n.li,{children:"Supports most terminal features"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="JnaTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class JnaTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create a JNA-based terminal\n        Terminal terminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("jna")  // Explicitly select JNA provider\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n        System.out.println("Terminal size: " + terminal.getWidth() + "x" + terminal.getHeight());\n\n        terminal.writer().println("Hello from JNA terminal!");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"jline-terminal-jansi",children:"JLine Terminal-Jansi"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"jline-terminal-jansi"})," module provides terminal implementations using the Jansi library. Jansi is particularly useful for Windows systems, where it provides ANSI escape sequence support."]}),"\n",(0,l.jsx)(n.h3,{id:"features-1",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cross-platform ANSI support"}),"\n",(0,l.jsx)(n.li,{children:"Enhanced Windows terminal support"}),"\n",(0,l.jsx)(n.li,{children:"Color and cursor positioning on Windows command prompt"}),"\n",(0,l.jsx)(n.li,{children:"Automatic detection of Windows console vs. Cygwin/MSYS/MinGW"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage-1",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="JansiTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class JansiTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create a Jansi-based terminal\n        Terminal terminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("jansi")  // Explicitly select Jansi provider\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n\n        // Use ANSI escape sequences for colors\n        terminal.writer().println("\\u001B[1;31mRed text\\u001B[0m");\n        terminal.writer().println("\\u001B[1;32mGreen text\\u001B[0m");\n        terminal.writer().println("\\u001B[1;34mBlue text\\u001B[0m");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"jline-terminal-ffm",children:"JLine Terminal-FFM"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"jline-terminal-ffm"})," module provides terminal implementations leveraging the Foreign Function & Memory API introduced in Java 21. This is the most modern approach and is recommended for applications running on Java 21 or later."]}),"\n",(0,l.jsx)(n.h3,{id:"features-2",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Uses standard Java API for native interoperability"}),"\n",(0,l.jsx)(n.li,{children:"No additional native libraries required"}),"\n",(0,l.jsx)(n.li,{children:"Good performance"}),"\n",(0,l.jsx)(n.li,{children:"Clean integration with modern Java"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage-2",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="FfmTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class FfmTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create an FFM-based terminal (requires Java 22+)\n        Terminal terminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("ffm")  // Explicitly select FFM provider\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n\n        terminal.writer().println("Hello from FFM terminal!");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"jline-terminal-jni",children:"JLine Terminal-JNI"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"jline-terminal-jni"})," module provides terminal implementations using the Java Native Interface (JNI). This approach requires platform-specific compilation but offers the best performance."]}),"\n",(0,l.jsx)(n.h3,{id:"features-3",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Direct access to native functions"}),"\n",(0,l.jsx)(n.li,{children:"Best performance"}),"\n",(0,l.jsx)(n.li,{children:"Works on all platforms with appropriate native libraries"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage-3",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="JniTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class JniTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create a JNI-based terminal\n        Terminal terminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("jni")  // Explicitly select JNI provider\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n\n        terminal.writer().println("Hello from JNI terminal!");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"exec-terminal-provider",children:"Exec Terminal Provider"}),"\n",(0,l.jsx)(n.p,{children:"The Exec terminal provider is a fallback option that uses external processes to interact with the terminal. It's used when no other provider is available or when explicitly requested."}),"\n",(0,l.jsx)(n.h3,{id:"features-4",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Works without native libraries"}),"\n",(0,l.jsx)(n.li,{children:"Available on all platforms"}),"\n",(0,l.jsx)(n.li,{children:"Minimal dependencies"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Limited functionality"}),"\n",(0,l.jsx)(n.li,{children:"Slower than native providers"}),"\n",(0,l.jsx)(n.li,{children:"May not support all terminal features"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage-4",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="ExecTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class ExecTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create an Exec-based terminal\n        Terminal terminal = TerminalBuilder.builder()\n                .system(true)\n                .provider("exec")  // Explicitly select Exec provider\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n\n        terminal.writer().println("Hello from Exec terminal!");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"dumb-terminal",children:"Dumb Terminal"}),"\n",(0,l.jsx)(n.p,{children:'JLine also provides a "dumb" terminal implementation that doesn\'t rely on any native functionality. This is useful for environments where terminal capabilities are limited or unavailable.'}),"\n",(0,l.jsx)(n.h3,{id:"features-5",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Works in any environment"}),"\n",(0,l.jsx)(n.li,{children:"No dependencies"}),"\n",(0,l.jsx)(n.li,{children:"Simple implementation"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"limitations-1",children:"Limitations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No advanced terminal features"}),"\n",(0,l.jsx)(n.li,{children:"No color support"}),"\n",(0,l.jsx)(n.li,{children:"No cursor positioning"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"usage-5",children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",metastring:'title="DumbTerminalExample.java"',children:'import org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class DumbTerminalExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create a dumb terminal\n        Terminal terminal = TerminalBuilder.builder()\n                .dumb(true)  // Request a dumb terminal\n                .build();\n        // highlight-end\n\n        System.out.println("Terminal type: " + terminal.getType());\n\n        terminal.writer().println("Hello from dumb terminal!");\n        terminal.writer().flush();\n\n        terminal.close();\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(n.p,{children:"When working with JLine terminal providers, consider these best practices:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Let JLine Choose"}),": In most cases, let JLine automatically select the best provider for the current environment."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Include Multiple Providers"}),": Include dependencies for multiple providers to ensure JLine can find a suitable implementation."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Fallback Gracefully"}),": Handle cases where advanced terminal features might not be available."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Test on Different Platforms"}),": Test your application on different platforms to ensure it works with different terminal providers."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Consider Java Version"}),": Use the FFM provider for Java 22+ applications for the best integration with modern Java."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Check Terminal Capabilities"}),": Use the terminal's capabilities to determine what features are available."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Close Terminals"}),": Always close terminals when you're done with them to release resources."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Handle Exceptions"}),": Be prepared to handle exceptions that might occur when creating or using terminals."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,l.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,l.jsx)(n.h4,{id:"unable-to-create-a-system-terminal",children:"Unable to create a system terminal"}),"\n",(0,l.jsx)(n.p,{children:"This error occurs when JLine cannot find a suitable terminal provider. To resolve:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Check that you have included the appropriate terminal provider dependencies"}),"\n",(0,l.jsxs)(n.li,{children:["Try explicitly specifying a provider using ",(0,l.jsx)(n.code,{children:"TerminalBuilder"})]}),"\n",(0,l.jsx)(n.li,{children:"Fall back to a dumb terminal if necessary"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:'Terminal terminal;\ntry {\n    terminal = TerminalBuilder.builder()\n            .system(true)\n            .build();\n} catch (IOException e) {\n    System.err.println("Unable to create a system terminal: " + e.getMessage());\n    terminal = TerminalBuilder.builder()\n            .dumb(true)\n            .build();\n}\n'})}),"\n",(0,l.jsx)(n.h4,{id:"jnajansi-not-found",children:"JNA/Jansi not found"}),"\n",(0,l.jsx)(n.p,{children:"If you see errors about JNA or Jansi not being found, make sure you've included the appropriate dependencies:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:"\x3c!-- For JNA support --\x3e\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-jna</artifactId>\n    <version>3.29.0</version>\n</dependency>\n\n\x3c!-- For Jansi support --\x3e\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-terminal-jansi</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,l.jsx)(n.h4,{id:"illegal-reflective-access-warnings",children:"Illegal reflective access warnings"}),"\n",(0,l.jsx)(n.p,{children:"When using JNA or Jansi on newer Java versions, you might see warnings about illegal reflective access. These are generally harmless but can be addressed by:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Using the FFM provider on Java 21+"}),"\n",(0,l.jsxs)(n.li,{children:["Adding appropriate ",(0,l.jsx)(n.code,{children:"--add-opens"})," JVM arguments"]}),"\n",(0,l.jsx)(n.li,{children:"Suppressing the warnings if they don't affect functionality"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"terminal-size-issues",children:"Terminal size issues"}),"\n",(0,l.jsx)(n.p,{children:"If your application isn't correctly detecting the terminal size:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Check if you're running in a real terminal (not redirected)"}),"\n",(0,l.jsx)(n.li,{children:"Try different terminal providers"}),"\n",(0,l.jsx)(n.li,{children:"Provide a default size for non-interactive terminals"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"Terminal terminal = TerminalBuilder.builder()\n        .system(true)\n        .build();\n\nif (!terminal.getSize().getColumns() > 0) {\n    // Set a default size for non-interactive terminals\n    terminal.setSize(new Size(80, 24));\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>s});var r=i(6540);const l={},a=r.createContext(l);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);