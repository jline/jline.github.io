"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[1411],{56:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"modules/console","title":"JLine Console","description":"The jline-console module provides a framework for building interactive console applications. It includes infrastructure for command processing, argument parsing, and help generation, making it easier to create sophisticated command-line interfaces.","source":"@site/docs/modules/console.md","sourceDirName":"modules","slug":"/modules/console","permalink":"/docs/modules/console","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/modules/console.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"JLine Style","permalink":"/docs/modules/style"},"next":{"title":"JLine Console UI","permalink":"/docs/modules/console-ui"}}');var t=r(4848),a=r(8453);const l={sidebar_position:4},o="JLine Console",s={},m=[{value:"Maven Dependency",id:"maven-dependency",level:2},{value:"Command Framework",id:"command-framework",level:2},{value:"Creating Custom Commands",id:"creating-custom-commands",level:2},{value:"Command Completion",id:"command-completion",level:2},{value:"Command Groups",id:"command-groups",level:2},{value:"Script Execution",id:"script-execution",level:2},{value:"Variable Support",id:"variable-support",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"jline-console",children:"JLine Console"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"jline-console"})," module provides a framework for building interactive console applications. It includes infrastructure for command processing, argument parsing, and help generation, making it easier to create sophisticated command-line interfaces."]}),"\n",(0,t.jsx)(n.h2,{id:"maven-dependency",children:"Maven Dependency"}),"\n",(0,t.jsx)(n.p,{children:"To use the console module, add the following dependency to your project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-console</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"command-framework",children:"Command Framework"}),"\n",(0,t.jsx)(n.p,{children:"The console module provides a command framework that makes it easy to define and execute commands:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CommandFrameworkExample.java" showLineNumbers',children:'import org.jline.console.CommandInput;\nimport org.jline.console.CommandRegistry;\nimport org.jline.console.impl.AbstractCommandRegistry;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class CommandFrameworkExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        // highlight-start\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register commands\n        registry.registerCommand("echo", args -> {\n            terminal.writer().println(String.join(" ", args));\n            return 0;\n        });\n\n        registry.registerCommand("add", args -> {\n            try {\n                int sum = Arrays.stream(args)\n                        .mapToInt(Integer::parseInt)\n                        .sum();\n                terminal.writer().println("Sum: " + sum);\n                return 0;\n            } catch (NumberFormatException e) {\n                terminal.writer().println("Error: Invalid number format");\n                return 1;\n            }\n        });\n        // highlight-end\n\n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        PrintWriter writer = terminal.writer();\n        while (true) {\n            String line = reader.readLine("console> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                // Parse and execute the command\n                CommandInput input = new CommandInput(line, parser.parse(line, 0).words());\n                registry.execute(input);\n            } catch (Exception e) {\n                writer.println("Error: " + e.getMessage());\n            }\n            writer.flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-commands",children:"Creating Custom Commands"}),"\n",(0,t.jsxs)(n.p,{children:["You can create custom commands by implementing the ",(0,t.jsx)(n.code,{children:"Command"})," interface or extending ",(0,t.jsx)(n.code,{children:"AbstractCommand"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CustomCommandExample.java" showLineNumbers',children:'import org.jline.console.CommandInput;\nimport org.jline.console.CommandRegistry;\nimport org.jline.console.impl.AbstractCommand;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CustomCommandExample {\n    // highlight-start\n    // Custom command implementation\n    static class GreetCommand extends AbstractCommand {\n        public GreetCommand() {\n            super("greet", "Greet a person", "greet [name]");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            String name = args.isEmpty() ? "World" : args.get(0);\n            return "Hello, " + name + "!";\n        }\n    }\n\n    static class CalculateCommand extends AbstractCommand {\n        public CalculateCommand() {\n            super("calc", "Perform calculations", "calc <operation> <num1> <num2>");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            if (args.size() < 3) {\n                throw new IllegalArgumentException("Not enough arguments");\n            }\n\n            String operation = args.get(0);\n            double num1 = Double.parseDouble(args.get(1));\n            double num2 = Double.parseDouble(args.get(2));\n\n            switch (operation) {\n                case "add": return num1 + num2;\n                case "subtract": return num1 - num2;\n                case "multiply": return num1 * num2;\n                case "divide":\n                    if (num2 == 0) {\n                        throw new IllegalArgumentException("Cannot divide by zero");\n                    }\n                    return num1 / num2;\n                default:\n                    throw new IllegalArgumentException("Unknown operation: " + operation);\n            }\n        }\n    }\n    // highlight-end\n\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register custom commands\n        registry.registerCommand(new GreetCommand());\n        registry.registerCommand(new CalculateCommand());\n\n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        PrintWriter writer = terminal.writer();\n        while (true) {\n            String line = reader.readLine("custom> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                // Parse and execute the command\n                CommandInput input = new CommandInput(line, parser.parse(line, 0).words());\n                Object result = registry.execute(input);\n                if (result != null) {\n                    writer.println(result);\n                }\n            } catch (Exception e) {\n                writer.println("Error: " + e.getMessage());\n            }\n            writer.flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"command-completion",children:"Command Completion"}),"\n",(0,t.jsx)(n.p,{children:"The console module provides support for command completion:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CommandCompletionExample.java"',children:'import org.jline.console.CommandRegistry;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.console.impl.SystemRegistryImpl;\nimport org.jline.reader.Completer;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.reader.impl.completer.ArgumentCompleter;\nimport org.jline.reader.impl.completer.NullCompleter;\nimport org.jline.reader.impl.completer.StringsCompleter;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class CommandCompletionExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register commands\n        registry.registerCommand("help", args -> {\n            terminal.writer().println("Available commands: help, echo, exit");\n            return 0;\n        });\n\n        registry.registerCommand("echo", args -> {\n            terminal.writer().println(String.join(" ", args));\n            return 0;\n        });\n\n        // highlight-start\n        // Create completers for commands\n        Completer helpCompleter = new ArgumentCompleter(\n                new StringsCompleter("help"),\n                NullCompleter.INSTANCE\n        );\n\n        Completer echoCompleter = new ArgumentCompleter(\n                new StringsCompleter("echo"),\n                new StringsCompleter("hello", "world", "test")\n        );\n\n        // Register completers\n        registry.registerCompleter("help", helpCompleter);\n        registry.registerCompleter("echo", echoCompleter);\n        // highlight-end\n\n        // Create a line reader with the registry\'s completer\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        while (true) {\n            String line = reader.readLine("completion> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                registry.execute(line);\n            } catch (Exception e) {\n                terminal.writer().println("Error: " + e.getMessage());\n            }\n            terminal.writer().flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"command-groups",children:"Command Groups"}),"\n",(0,t.jsx)(n.p,{children:"You can organize commands into groups:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CommandGroupsExample.java" showLineNumbers',children:'import org.jline.console.CommandInput;\nimport org.jline.console.CommandRegistry;\nimport org.jline.console.impl.AbstractCommand;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CommandGroupsExample {\n    // File commands\n    // highlight-start\n    static class ListCommand extends AbstractCommand {\n        public ListCommand() {\n            super("file:list", "List files", "file:list [directory]");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            String dir = args.isEmpty() ? "." : args.get(0);\n            return "Listing files in " + dir;\n        }\n    }\n\n    static class CatCommand extends AbstractCommand {\n        public CatCommand() {\n            super("file:cat", "Display file contents", "file:cat <file>");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            if (args.isEmpty()) {\n                throw new IllegalArgumentException("File name required");\n            }\n            return "Contents of " + args.get(0);\n        }\n    }\n\n    // Network commands\n    static class PingCommand extends AbstractCommand {\n        public PingCommand() {\n            super("net:ping", "Ping a host", "net:ping <host>");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            if (args.isEmpty()) {\n                throw new IllegalArgumentException("Host required");\n            }\n            return "Pinging " + args.get(0);\n        }\n    }\n\n    static class HttpCommand extends AbstractCommand {\n        public HttpCommand() {\n            super("net:http", "Make HTTP request", "net:http <url>");\n        }\n\n        @Override\n        public Object execute(CommandInput input) {\n            List<String> args = input.args();\n            if (args.isEmpty()) {\n                throw new IllegalArgumentException("URL required");\n            }\n            return "Fetching " + args.get(0);\n        }\n    }\n    // highlight-end\n\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register commands by group\n        registry.registerCommand(new ListCommand());\n        registry.registerCommand(new CatCommand());\n        registry.registerCommand(new PingCommand());\n        registry.registerCommand(new HttpCommand());\n\n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        PrintWriter writer = terminal.writer();\n        while (true) {\n            String line = reader.readLine("groups> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                // Parse and execute the command\n                CommandInput input = new CommandInput(line, parser.parse(line, 0).words());\n                Object result = registry.execute(input);\n                if (result != null) {\n                    writer.println(result);\n                }\n            } catch (Exception e) {\n                writer.println("Error: " + e.getMessage());\n            }\n            writer.flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"script-execution",children:"Script Execution"}),"\n",(0,t.jsx)(n.p,{children:"The console module supports executing scripts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="ScriptExecutionExample.java"',children:'import org.jline.console.CommandRegistry;\nimport org.jline.console.ScriptEngine;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.console.impl.SystemRegistryImpl;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class ScriptExecutionExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n        PrintWriter writer = terminal.writer();\n\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register basic commands\n        registry.registerCommand("echo", args -> {\n            writer.println(String.join(" ", args));\n            return 0;\n        });\n\n        registry.registerCommand("add", args -> {\n            int sum = 0;\n            for (String arg : args) {\n                sum += Integer.parseInt(arg);\n            }\n            writer.println("Sum: " + sum);\n            return sum;\n        });\n\n        // highlight-start\n        // Create a script engine\n        ScriptEngine engine = new ScriptEngine() {\n            @Override\n            public Object execute(CommandRegistry commandRegistry, String script) {\n                String[] lines = script.split("\\n");\n                Object result = null;\n\n                for (String line : lines) {\n                    line = line.trim();\n                    if (line.isEmpty() || line.startsWith("#")) {\n                        continue; // Skip empty lines and comments\n                    }\n\n                    try {\n                        result = commandRegistry.execute(line);\n                    } catch (Exception e) {\n                        writer.println("Error executing script line: " + line);\n                        writer.println("  " + e.getMessage());\n                        return 1; // Error code\n                    }\n                }\n\n                return result;\n            }\n\n            @Override\n            public boolean hasVariable(String name) {\n                return false;\n            }\n\n            @Override\n            public Object getVariable(String name) {\n                return null;\n            }\n\n            @Override\n            public void putVariable(String name, Object value) {\n                // Not implemented\n            }\n        };\n        // highlight-end\n\n        // Register script execution command\n        registry.registerCommand("source", args -> {\n            if (args.isEmpty()) {\n                writer.println("Usage: source <script-file>");\n                return 1;\n            }\n\n            Path scriptPath = Paths.get(args.get(0));\n            if (!Files.exists(scriptPath)) {\n                writer.println("Script file not found: " + scriptPath);\n                return 1;\n            }\n\n            try {\n                List<String> scriptLines = Files.readAllLines(scriptPath);\n                String script = String.join("\\n", scriptLines);\n                return engine.execute(registry, script);\n            } catch (IOException e) {\n                writer.println("Error reading script file: " + e.getMessage());\n                return 1;\n            }\n        });\n\n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        while (true) {\n            String line = reader.readLine("script> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                registry.execute(line);\n            } catch (Exception e) {\n                writer.println("Error: " + e.getMessage());\n            }\n            writer.flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"variable-support",children:"Variable Support"}),"\n",(0,t.jsx)(n.p,{children:"The console module provides support for variables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="VariableSupportExample.java" showLineNumbers',children:'import org.jline.console.CommandRegistry;\nimport org.jline.console.impl.DefaultCommandRegistry;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class VariableSupportExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        DefaultParser parser = new DefaultParser();\n        PrintWriter writer = terminal.writer();\n\n        // highlight-start\n        // Create a variable store\n        Map<String, Object> variables = new HashMap<>();\n\n        // Pattern to match variable references\n        Pattern varPattern = Pattern.compile("\\\\$([a-zA-Z0-9_]+)");\n        // highlight-end\n\n        // Create a command registry\n        CommandRegistry registry = new DefaultCommandRegistry();\n\n        // Register variable commands\n        registry.registerCommand("set", args -> {\n            if (args.size() < 2) {\n                writer.println("Usage: set <name> <value>");\n                return 1;\n            }\n\n            String name = args.get(0);\n            String value = args.get(1);\n            variables.put(name, value);\n            writer.println(name + " = " + value);\n            return 0;\n        });\n\n        registry.registerCommand("get", args -> {\n            if (args.isEmpty()) {\n                // List all variables\n                variables.forEach((name, value) -> writer.println(name + " = " + value));\n            } else {\n                // Get specific variable\n                String name = args.get(0);\n                if (variables.containsKey(name)) {\n                    writer.println(name + " = " + variables.get(name));\n                } else {\n                    writer.println("Variable not found: " + name);\n                    return 1;\n                }\n            }\n            return 0;\n        });\n\n        registry.registerCommand("echo", args -> {\n            StringBuilder result = new StringBuilder();\n\n            for (String arg : args) {\n                // Replace variable references\n                Matcher matcher = varPattern.matcher(arg);\n                StringBuffer sb = new StringBuffer();\n\n                while (matcher.find()) {\n                    String varName = matcher.group(1);\n                    String varValue = variables.containsKey(varName)\n                            ? variables.get(varName).toString()\n                            : "$" + varName;\n                    matcher.appendReplacement(sb, Matcher.quoteReplacement(varValue));\n                }\n                matcher.appendTail(sb);\n\n                result.append(sb).append(" ");\n            }\n\n            writer.println(result.toString().trim());\n            return 0;\n        });\n\n        // Create a line reader\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .parser(parser)\n                .completer(registry.completer())\n                .build();\n\n        // Main command loop\n        while (true) {\n            String line = reader.readLine("vars> ");\n            if (line.trim().equalsIgnoreCase("exit")) {\n                break;\n            }\n\n            try {\n                registry.execute(line);\n            } catch (Exception e) {\n                writer.println("Error: " + e.getMessage());\n            }\n            writer.flush();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"When using the JLine console module, consider these best practices:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Organize Commands Logically"}),": Group related commands together to make them easier to discover and use."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Provide Helpful Command Descriptions"}),": Include clear descriptions and usage information for each command."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implement Tab Completion"}),": Add completers for commands to improve usability."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handle Errors Gracefully"}),": Catch and handle exceptions appropriately, providing helpful error messages."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Command Groups"}),": Organize commands into groups for better organization in larger applications."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Support Script Execution"}),": Allow users to automate tasks by executing scripts."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implement Variable Support"}),": Variables make scripts more flexible and powerful."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Provide Help Commands"}),": Include commands that display help information for other commands."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Follow Consistent Command Syntax"}),": Use a consistent syntax for all commands to make them easier to learn and use."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Support Command History"}),": Leverage JLine's history capabilities to allow users to recall and edit previous commands."]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);