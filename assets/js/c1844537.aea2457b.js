"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[3700],{2533:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"advanced/library-integration","title":"JLine Integration with Other Libraries","description":"JLine works well with other Java libraries to create powerful command-line applications. This guide covers how to integrate JLine with popular command-line frameworks and libraries to enhance your terminal applications.","source":"@site/docs/advanced/library-integration.md","sourceDirName":"advanced","slug":"/advanced/library-integration","permalink":"/docs/advanced/library-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/library-integration.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Screen Clearing and Terminal Control","permalink":"/docs/advanced/screen-clearing"},"next":{"title":"JLine Modules Overview","permalink":"/docs/modules/overview"}}');var t=i(4848),a=i(8453);const o={sidebar_position:11},l="JLine Integration with Other Libraries",s={},m=[{value:"Integration with Picocli",id:"integration-with-picocli",level:2},{value:"Setting Up JLine with Picocli",id:"setting-up-jline-with-picocli",level:3},{value:"Basic Integration Example",id:"basic-integration-example",level:3},{value:"Advanced Integration with Tab Completion",id:"advanced-integration-with-tab-completion",level:3},{value:"Integration with Spring Shell",id:"integration-with-spring-shell",level:2},{value:"Setting Up JLine with Spring Shell",id:"setting-up-jline-with-spring-shell",level:3},{value:"Customizing JLine in Spring Shell",id:"customizing-jline-in-spring-shell",level:3},{value:"Integration with Apache Commons CLI",id:"integration-with-apache-commons-cli",level:2},{value:"Setting Up JLine with Commons CLI",id:"setting-up-jline-with-commons-cli",level:3},{value:"Basic Integration Example",id:"basic-integration-example-1",level:3},{value:"Integration with JCommander",id:"integration-with-jcommander",level:2},{value:"Setting Up JLine with JCommander",id:"setting-up-jline-with-jcommander",level:3},{value:"Basic Integration Example",id:"basic-integration-example-2",level:3},{value:"Integration with JLine Builtins",id:"integration-with-jline-builtins",level:2},{value:"Best Practices for Library Integration",id:"best-practices-for-library-integration",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"jline-integration-with-other-libraries",children:"JLine Integration with Other Libraries"})}),"\n",(0,t.jsx)(e.p,{children:"JLine works well with other Java libraries to create powerful command-line applications. This guide covers how to integrate JLine with popular command-line frameworks and libraries to enhance your terminal applications."}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-picocli",children:"Integration with Picocli"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://picocli.info/",children:"Picocli"})," is a modern framework for building command-line applications. It offers annotation-based command parsing, type conversion, validation, and more. Integrating JLine with Picocli provides rich interactive features for your command-line applications."]}),"\n",(0,t.jsx)(e.h3,{id:"setting-up-jline-with-picocli",children:"Setting Up JLine with Picocli"}),"\n",(0,t.jsx)(e.p,{children:"To integrate JLine with Picocli, you'll need the following dependencies:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<dependency>\n    <groupId>info.picocli</groupId>\n    <artifactId>picocli</artifactId>\n    <version>4.7.5</version>\n</dependency>\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline</artifactId>\n    <version>3.29.0</version>\n</dependency>\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline-builtins</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(e.h3,{id:"basic-integration-example",children:"Basic Integration Example"}),"\n",(0,t.jsx)(e.p,{children:"Here's a basic example of integrating JLine with Picocli:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="PicocliJLineExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.ParsedLine;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.Parameters;\n\nimport java.io.IOException;\nimport java.util.concurrent.Callable;\n\npublic class PicocliJLineExample {\n    public static void main(String[] args) {\n        try {\n            // Set up the terminal\n            Terminal terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n\n            // Set up the line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .build();\n\n            // Create the command line parser\n            MyCommand myCommand = new MyCommand(terminal);\n            CommandLine cmd = new CommandLine(myCommand);\n\n            // Main interactive loop\n            while (true) {\n                String line = reader.readLine("example> ");\n\n                // Exit if requested\n                if (line.equalsIgnoreCase("exit") || line.equalsIgnoreCase("quit")) {\n                    break;\n                }\n\n                try {\n                    // Parse and execute the command\n                    ParsedLine pl = reader.getParser().parse(line, 0);\n                    String[] arguments = pl.words().toArray(new String[0]);\n                    cmd.execute(arguments);\n                } catch (Exception e) {\n                    terminal.writer().println("Error: " + e.getMessage());\n                    terminal.flush();\n                }\n            }\n\n            terminal.writer().println("Goodbye!");\n            terminal.close();\n\n        } catch (IOException e) {\n            System.err.println("Error creating terminal: " + e.getMessage());\n        }\n    }\n\n    // Define a command using Picocli annotations\n    @Command(name = "example", mixinStandardHelpOptions = true, version = "1.0",\n             description = "Example command using JLine and Picocli")\n    static class MyCommand implements Callable<Integer> {\n        private final Terminal terminal;\n\n        @Option(names = {"-c", "--count"}, description = "Number of times to repeat")\n        private int count = 1;\n\n        @Parameters(index = "0", description = "The message to display")\n        private String message;\n\n        public MyCommand(Terminal terminal) {\n            this.terminal = terminal;\n        }\n\n        @Override\n        public Integer call() {\n            if (message == null) {\n                terminal.writer().println("No message provided. Use --help for usage information.");\n            } else {\n                for (int i = 0; i < count; i++) {\n                    terminal.writer().println(message);\n                }\n            }\n            terminal.flush();\n            return 0;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"advanced-integration-with-tab-completion",children:"Advanced Integration with Tab Completion"}),"\n",(0,t.jsx)(e.p,{children:"You can enhance the integration with tab completion for Picocli commands:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="PicocliCompletionExample.java" showLineNumbers',children:'import org.jline.reader.Candidate;\nimport org.jline.reader.Completer;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.ParsedLine;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.Parameters;\nimport picocli.shell.jline3.PicocliJLineCompleter;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.Callable;\n\npublic class PicocliCompletionExample {\n    public static void main(String[] args) {\n        try {\n            // Set up the terminal\n            Terminal terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n\n            // Create the command line parser\n            RootCommand rootCommand = new RootCommand(terminal);\n            CommandLine commandLine = new CommandLine(rootCommand);\n\n            // Add subcommands\n            commandLine.addSubcommand("hello", new HelloCommand(terminal));\n            commandLine.addSubcommand("echo", new EchoCommand(terminal));\n\n            // Create a completer for the command line\n            Completer completer = new PicocliJLineCompleter(commandLine.getCommandSpec());\n\n            // Set up the line reader with completion\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .completer(completer)\n                    .build();\n\n            // Main interactive loop\n            while (true) {\n                String line = reader.readLine("cli> ");\n\n                // Exit if requested\n                if (line.equalsIgnoreCase("exit") || line.equalsIgnoreCase("quit")) {\n                    break;\n                }\n\n                try {\n                    // Parse and execute the command\n                    ParsedLine pl = reader.getParser().parse(line, 0);\n                    String[] arguments = pl.words().toArray(new String[0]);\n                    commandLine.execute(arguments);\n                } catch (Exception e) {\n                    terminal.writer().println("Error: " + e.getMessage());\n                    terminal.flush();\n                }\n            }\n\n            terminal.writer().println("Goodbye!");\n            terminal.close();\n\n        } catch (IOException e) {\n            System.err.println("Error creating terminal: " + e.getMessage());\n        }\n    }\n\n    // Root command\n    @Command(name = "cli", mixinStandardHelpOptions = true, version = "1.0",\n             description = "Interactive CLI with JLine and Picocli")\n    static class RootCommand implements Callable<Integer> {\n        private final Terminal terminal;\n\n        public RootCommand(Terminal terminal) {\n            this.terminal = terminal;\n        }\n\n        @Override\n        public Integer call() {\n            terminal.writer().println("Use one of the available commands:");\n            terminal.writer().println("  hello - Say hello");\n            terminal.writer().println("  echo - Echo a message");\n            terminal.writer().println("  help - Show help");\n            terminal.writer().println("  exit - Exit the application");\n            terminal.flush();\n            return 0;\n        }\n    }\n\n    // Hello command\n    @Command(name = "hello", description = "Say hello")\n    static class HelloCommand implements Callable<Integer> {\n        private final Terminal terminal;\n\n        @Option(names = {"-n", "--name"}, description = "Name to greet")\n        private String name = "World";\n\n        public HelloCommand(Terminal terminal) {\n            this.terminal = terminal;\n        }\n\n        @Override\n        public Integer call() {\n            terminal.writer().println("Hello, " + name + "!");\n            terminal.flush();\n            return 0;\n        }\n    }\n\n    // Echo command\n    @Command(name = "echo", description = "Echo a message")\n    static class EchoCommand implements Callable<Integer> {\n        private final Terminal terminal;\n\n        @Option(names = {"-u", "--uppercase"}, description = "Convert to uppercase")\n        private boolean uppercase;\n\n        @Parameters(description = "Message to echo")\n        private List<String> message;\n\n        public EchoCommand(Terminal terminal) {\n            this.terminal = terminal;\n        }\n\n        @Override\n        public Integer call() {\n            if (message == null || message.isEmpty()) {\n                terminal.writer().println("No message provided");\n            } else {\n                String result = String.join(" ", message);\n                if (uppercase) {\n                    result = result.toUpperCase();\n                }\n                terminal.writer().println(result);\n            }\n            terminal.flush();\n            return 0;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-spring-shell",children:"Integration with Spring Shell"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://spring.io/projects/spring-shell",children:"Spring Shell"})," is a framework for building command-line applications using the Spring Framework. It provides a rich set of features for building interactive shells."]}),"\n",(0,t.jsx)(e.h3,{id:"setting-up-jline-with-spring-shell",children:"Setting Up JLine with Spring Shell"}),"\n",(0,t.jsx)(e.p,{children:"Spring Shell already uses JLine internally, but you can customize the JLine configuration:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.springframework.shell</groupId>\n    <artifactId>spring-shell-starter</artifactId>\n    <version>3.1.3</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(e.h3,{id:"customizing-jline-in-spring-shell",children:"Customizing JLine in Spring Shell"}),"\n",(0,t.jsx)(e.p,{children:"You can customize the JLine configuration in Spring Shell by providing custom beans:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="SpringShellJLineExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedString;\nimport org.jline.utils.AttributedStyle;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.shell.command.CommandRegistration;\nimport org.springframework.shell.command.CommandRegistration.Builder;\nimport org.springframework.shell.standard.ShellComponent;\nimport org.springframework.shell.standard.ShellMethod;\nimport org.springframework.shell.standard.ShellOption;\n\nimport java.io.IOException;\n\n@SpringBootApplication\npublic class SpringShellJLineExample {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringShellJLineExample.class, args);\n    }\n\n    // Customize the terminal\n    @Bean\n    public Terminal terminal() throws IOException {\n        return TerminalBuilder.builder()\n                .system(true)\n                .build();\n    }\n\n    // Customize the line reader\n    @Bean\n    public LineReader lineReader(Terminal terminal) {\n        return LineReaderBuilder.builder()\n                .terminal(terminal)\n                .option(LineReader.Option.AUTO_FRESH_LINE, true)\n                .option(LineReader.Option.HISTORY_BEEP, false)\n                .build();\n    }\n\n    // Customize the prompt\n    @Bean\n    public org.springframework.shell.jline.PromptProvider promptProvider() {\n        return () -> new AttributedString("custom-shell:> ",\n                AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW));\n    }\n\n    // Register a command programmatically\n    @Bean\n    public CommandRegistration echoCommand() {\n        Builder builder = CommandRegistration.builder();\n        return builder\n                .command("echo")\n                .description("Echo a message")\n                .withOption()\n                    .longNames("message")\n                    .shortNames(\'m\')\n                    .description("The message to echo")\n                    .required()\n                    .and()\n                .withOption()\n                    .longNames("uppercase")\n                    .shortNames(\'u\')\n                    .description("Convert to uppercase")\n                    .defaultValue("false")\n                    .and()\n                .withTarget()\n                    .function(ctx -> {\n                        String message = ctx.getOptionValue("message");\n                        boolean uppercase = Boolean.parseBoolean(ctx.getOptionValue("uppercase"));\n\n                        if (uppercase) {\n                            message = message.toUpperCase();\n                        }\n\n                        return message;\n                    })\n                    .and()\n                .build();\n    }\n\n    // Define a command using annotations\n    @ShellComponent\n    public static class MyCommands {\n        @ShellMethod(key = "hello", value = "Say hello")\n        public String hello(@ShellOption(defaultValue = "World") String name) {\n            return "Hello, " + name + "!";\n        }\n\n        @ShellMethod(key = "sum", value = "Sum two numbers")\n        public int sum(int a, int b) {\n            return a + b;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-apache-commons-cli",children:"Integration with Apache Commons CLI"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://commons.apache.org/proper/commons-cli/",children:"Apache Commons CLI"})," is a simple library for parsing command-line options. While it doesn't provide interactive features like Picocli or Spring Shell, you can combine it with JLine for a basic interactive shell."]}),"\n",(0,t.jsx)(e.h3,{id:"setting-up-jline-with-commons-cli",children:"Setting Up JLine with Commons CLI"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<dependency>\n    <groupId>commons-cli</groupId>\n    <artifactId>commons-cli</artifactId>\n    <version>1.5.0</version>\n</dependency>\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(e.h3,{id:"basic-integration-example-1",children:"Basic Integration Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="CommonsCliJLineExample.java" showLineNumbers',children:'import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class CommonsCliJLineExample {\n    public static void main(String[] args) {\n        try {\n            // Set up the terminal\n            Terminal terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n\n            // Set up the line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .build();\n\n            // Define CLI options\n            Options options = new Options();\n            options.addOption(Option.builder("h")\n                    .longOpt("help")\n                    .desc("Show help")\n                    .build());\n            options.addOption(Option.builder("g")\n                    .longOpt("greet")\n                    .desc("Greet someone")\n                    .hasArg()\n                    .argName("name")\n                    .build());\n            options.addOption(Option.builder("c")\n                    .longOpt("count")\n                    .desc("Count to a number")\n                    .hasArg()\n                    .argName("number")\n                    .type(Number.class)\n                    .build());\n\n            // Create the parser\n            CommandLineParser parser = new DefaultParser();\n            HelpFormatter formatter = new HelpFormatter();\n\n            // Main interactive loop\n            while (true) {\n                String line = reader.readLine("cli> ");\n\n                // Exit if requested\n                if (line.equalsIgnoreCase("exit") || line.equalsIgnoreCase("quit")) {\n                    break;\n                }\n\n                // Parse the command line\n                try {\n                    String[] arguments = line.split("\\\\s+");\n                    CommandLine cmd = parser.parse(options, arguments);\n\n                    // Process the command\n                    if (cmd.hasOption("help")) {\n                        formatter.printHelp(terminal.writer(), 80, "cli",\n                                "CLI Example", options, 2, 2,\n                                "Use \'exit\' to quit", true);\n                    } else if (cmd.hasOption("greet")) {\n                        String name = cmd.getOptionValue("greet", "World");\n                        terminal.writer().println("Hello, " + name + "!");\n                    } else if (cmd.hasOption("count")) {\n                        try {\n                            int count = Integer.parseInt(cmd.getOptionValue("count", "10"));\n                            for (int i = 1; i <= count; i++) {\n                                terminal.writer().println(i);\n                            }\n                        } catch (NumberFormatException e) {\n                            terminal.writer().println("Error: Invalid number format");\n                        }\n                    } else {\n                        // Handle command arguments\n                        String[] cmdArgs = cmd.getArgs();\n                        if (cmdArgs.length > 0) {\n                            terminal.writer().println("Arguments: " + Arrays.toString(cmdArgs));\n                        } else {\n                            terminal.writer().println("No command specified. Use --help for usage information.");\n                        }\n                    }\n                } catch (ParseException e) {\n                    terminal.writer().println("Error: " + e.getMessage());\n                    formatter.printHelp(terminal.writer(), 80, "cli",\n                            "CLI Example", options, 2, 2,\n                            "Use \'exit\' to quit", true);\n                }\n\n                terminal.flush();\n            }\n\n            terminal.writer().println("Goodbye!");\n            terminal.close();\n\n        } catch (IOException e) {\n            System.err.println("Error creating terminal: " + e.getMessage());\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-jcommander",children:"Integration with JCommander"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://jcommander.org/",children:"JCommander"})," is a command-line parsing framework that uses annotations to define parameters. Here's how to integrate it with JLine:"]}),"\n",(0,t.jsx)(e.h3,{id:"setting-up-jline-with-jcommander",children:"Setting Up JLine with JCommander"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<dependency>\n    <groupId>com.beust</groupId>\n    <artifactId>jcommander</artifactId>\n    <version>1.82</version>\n</dependency>\n<dependency>\n    <groupId>org.jline</groupId>\n    <artifactId>jline</artifactId>\n    <version>3.29.0</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(e.h3,{id:"basic-integration-example-2",children:"Basic Integration Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="JCommanderJLineExample.java" showLineNumbers',children:'import com.beust.jcommander.JCommander;\nimport com.beust.jcommander.Parameter;\nimport com.beust.jcommander.Parameters;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JCommanderJLineExample {\n    public static void main(String[] args) {\n        try {\n            // Set up the terminal\n            Terminal terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n\n            // Set up the line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .build();\n\n            // Create command objects\n            MainCommand mainCommand = new MainCommand();\n            GreetCommand greetCommand = new GreetCommand();\n            CountCommand countCommand = new CountCommand();\n\n            // Set up JCommander\n            JCommander jc = JCommander.newBuilder()\n                    .addObject(mainCommand)\n                    .addCommand("greet", greetCommand)\n                    .addCommand("count", countCommand)\n                    .build();\n\n            // Main interactive loop\n            while (true) {\n                String line = reader.readLine("jcmd> ");\n\n                // Exit if requested\n                if (line.equalsIgnoreCase("exit") || line.equalsIgnoreCase("quit")) {\n                    break;\n                }\n\n                try {\n                    // Parse the command line\n                    String[] arguments = line.split("\\\\s+");\n\n                    // Reset state\n                    mainCommand.help = false;\n                    jc.parse(arguments);\n\n                    // Process the command\n                    if (mainCommand.help) {\n                        jc.usage();\n                    } else {\n                        String parsedCommand = jc.getParsedCommand();\n                        if (parsedCommand == null) {\n                            terminal.writer().println("No command specified. Use --help for usage information.");\n                        } else if (parsedCommand.equals("greet")) {\n                            terminal.writer().println("Hello, " + greetCommand.name + "!");\n                        } else if (parsedCommand.equals("count")) {\n                            for (int i = 1; i <= countCommand.number; i++) {\n                                terminal.writer().println(i);\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    terminal.writer().println("Error: " + e.getMessage());\n                    jc.usage();\n                }\n\n                terminal.flush();\n            }\n\n            terminal.writer().println("Goodbye!");\n            terminal.close();\n\n        } catch (IOException e) {\n            System.err.println("Error creating terminal: " + e.getMessage());\n        }\n    }\n\n    // Main command parameters\n    static class MainCommand {\n        @Parameter(names = {"--help", "-h"}, help = true, description = "Show help")\n        boolean help;\n    }\n\n    // Greet command\n    @Parameters(commandDescription = "Greet someone")\n    static class GreetCommand {\n        @Parameter(names = {"--name", "-n"}, description = "Name to greet")\n        String name = "World";\n    }\n\n    // Count command\n    @Parameters(commandDescription = "Count to a number")\n    static class CountCommand {\n        @Parameter(names = {"--number", "-n"}, description = "Number to count to")\n        int number = 10;\n\n        @Parameter(description = "Additional arguments")\n        List<String> args = new ArrayList<>();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-jline-builtins",children:"Integration with JLine Builtins"}),"\n",(0,t.jsxs)(e.p,{children:["JLine provides its own set of built-in commands and utilities in the ",(0,t.jsx)(e.code,{children:"jline-builtins"})," module. These can be used to create a rich interactive shell:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="JLineBuiltinsExample.java" showLineNumbers',children:'import org.jline.builtins.Builtins;\nimport org.jline.builtins.Completers.SystemCompleter;\nimport org.jline.builtins.Options.HelpException;\nimport org.jline.builtins.Widgets;\nimport org.jline.reader.Completer;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.MaskingCallback;\nimport org.jline.reader.ParsedLine;\nimport org.jline.reader.Parser;\nimport org.jline.reader.impl.DefaultParser;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class JLineBuiltinsExample {\n    public static void main(String[] args) {\n        try {\n            // Set up the terminal\n            Terminal terminal = TerminalBuilder.builder()\n                    .system(true)\n                    .build();\n\n            // Set up the parser\n            Parser parser = new DefaultParser();\n\n            // Set up the builtins\n            Path currentDir = Paths.get("").toAbsolutePath();\n            Builtins builtins = new Builtins(currentDir, null, null);\n            SystemCompleter systemCompleter = builtins.compileCompleters();\n\n            // Set up custom commands\n            Map<String, Supplier<String>> customCommands = new HashMap<>();\n            customCommands.put("hello", () -> "Hello, World!");\n            customCommands.put("date", () -> new java.util.Date().toString());\n\n            // Add completers for custom commands\n            systemCompleter.add("hello", systemCompleter.compileCompleter(List.of()));\n            systemCompleter.add("date", systemCompleter.compileCompleter(List.of()));\n\n            // Set up the line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .completer(systemCompleter)\n                    .parser(parser)\n                    .build();\n\n            // Set up widgets\n            Widgets widgets = new Widgets(reader);\n            widgets.addWidget("custom-widget", () -> {\n                reader.getBuffer().write("Hello from custom widget!");\n                return true;\n            });\n\n            // Bind widget to key\n            reader.getKeyMaps().get(LineReader.MAIN).bind(\n                    widgets.getWidget("custom-widget"),\n                    "\\033w");  // Alt+W\n\n            // Create a custom prompt\n            Supplier<String> prompt = () -> {\n                String p = new AttributedStringBuilder()\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW))\n                        .append("shell:")\n                        .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))\n                        .append(currentDir.getFileName().toString())\n                        .style(AttributedStyle.DEFAULT)\n                        .append("> ")\n                        .toAnsi();\n                return p;\n            };\n\n            // Main interactive loop\n            PrintWriter writer = terminal.writer();\n\n            // Display welcome message\n            writer.println("JLine Builtins Example");\n            writer.println("---------------------");\n            writer.println("Type \'help\' to see available commands");\n            writer.println("Press Alt+W to trigger the custom widget");\n            writer.println("Type \'exit\' to quit");\n            writer.println();\n            writer.flush();\n\n            while (true) {\n                String line = reader.readLine(prompt.get(), null, (MaskingCallback) null, null);\n\n                // Exit if requested\n                if (line.equalsIgnoreCase("exit") || line.equalsIgnoreCase("quit")) {\n                    break;\n                }\n\n                // Parse the line\n                ParsedLine pl = parser.parse(line, 0);\n                String command = pl.words().get(0);\n\n                try {\n                    // Check for builtins\n                    if (builtins.hasCommand(command)) {\n                        builtins.execute(command, pl.words().subList(1, pl.words().size()).toArray(new String[0]),\n                                System.in, writer, writer, terminal);\n                    }\n                    // Check for custom commands\n                    else if (customCommands.containsKey(command)) {\n                        writer.println(customCommands.get(command).get());\n                    }\n                    // Unknown command\n                    else {\n                        writer.println("Unknown command: " + command);\n                        writer.println("Type \'help\' to see available commands");\n                    }\n                } catch (HelpException e) {\n                    writer.println(e.getMessage());\n                } catch (Exception e) {\n                    writer.println("Error: " + e.getMessage());\n                }\n\n                writer.flush();\n            }\n\n            writer.println("Goodbye!");\n            terminal.close();\n\n        } catch (IOException e) {\n            System.err.println("Error creating terminal: " + e.getMessage());\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-library-integration",children:"Best Practices for Library Integration"}),"\n",(0,t.jsx)(e.p,{children:"When integrating JLine with other libraries, follow these best practices:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Separate concerns"}),": Keep command parsing logic separate from terminal handling."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Handle exceptions gracefully"}),": Catch and handle exceptions from both JLine and the integrated library."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Provide helpful error messages"}),": When command parsing fails, provide clear error messages and usage information."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Add tab completion"}),": Enhance the user experience with tab completion for commands and arguments."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Customize the prompt"}),": Use a custom prompt to provide context and visual cues."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Support history"}),": Configure JLine's history feature to provide command history."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Add custom widgets"}),": Create custom widgets for frequently used actions."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Test thoroughly"}),": Test your integration with various commands and edge cases."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Handle terminal resizing"}),": Ensure your application responds appropriately to terminal resize events."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Provide a clean exit"}),": Clean up resources and restore the terminal state when exiting."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Integrating JLine with other command-line libraries allows you to create powerful, interactive terminal applications with rich features. Whether you're using Picocli, Spring Shell, Commons CLI, JCommander, or JLine's built-in utilities, JLine enhances the user experience with line editing, history, tab completion, and more."}),"\n",(0,t.jsx)(e.p,{children:"By following the examples and best practices in this guide, you can create sophisticated command-line applications that combine the strengths of JLine with your preferred command parsing library."})]})}function c(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>l});var r=i(6540);const t={},a=r.createContext(t);function o(n){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);