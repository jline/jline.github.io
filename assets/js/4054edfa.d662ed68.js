"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[9380],{6013:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"advanced/terminal-size","title":"Terminal Size Changes","description":"Terminal applications need to adapt to changes in terminal size to provide a good user experience. JLine provides mechanisms to detect and handle terminal size changes, allowing your application to respond appropriately when the user resizes their terminal window.","source":"@site/docs/advanced/terminal-size.md","sourceDirName":"advanced","slug":"/advanced/terminal-size","permalink":"/docs/advanced/terminal-size","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/advanced/terminal-size.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Mouse Support","permalink":"/docs/advanced/mouse-support"},"next":{"title":"Screen Clearing and Terminal Control","permalink":"/docs/advanced/screen-clearing"}}');var t=i(4848),l=i(8453);const a={sidebar_position:7},s="Terminal Size Changes",o={},m=[{value:"Detecting Terminal Size",id:"detecting-terminal-size",level:2},{value:"Handling Size Change Events",id:"handling-size-change-events",level:2},{value:"Adapting UI to Terminal Size",id:"adapting-ui-to-terminal-size",level:2},{value:"Handling Size Changes with LineReader",id:"handling-size-changes-with-linereader",level:2},{value:"Automatic Wrapping and Scrolling",id:"automatic-wrapping-and-scrolling",level:2},{value:"Minimum Size Requirements",id:"minimum-size-requirements",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"terminal-size-changes",children:"Terminal Size Changes"})}),"\n",(0,t.jsx)(e.p,{children:"Terminal applications need to adapt to changes in terminal size to provide a good user experience. JLine provides mechanisms to detect and handle terminal size changes, allowing your application to respond appropriately when the user resizes their terminal window."}),"\n",(0,t.jsx)(e.h2,{id:"detecting-terminal-size",children:"Detecting Terminal Size"}),"\n",(0,t.jsx)(e.p,{children:"JLine makes it easy to get the current terminal size:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="TerminalSizeExample.java" showLineNumbers',children:'import org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class TerminalSizeExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // highlight-start\n            // Get the current terminal size\n            Size size = terminal.getSize();\n            int columns = size.getColumns();\n            int rows = size.getRows();\n            // highlight-end\n            \n            terminal.writer().println("Terminal size information:");\n            terminal.writer().println("  Columns: " + columns);\n            terminal.writer().println("  Rows: " + rows);\n            terminal.writer().println();\n            \n            // Display a visual representation of the terminal size\n            terminal.writer().println("Visual representation of terminal size:");\n            \n            // Top border\n            terminal.writer().print("+");\n            for (int i = 0; i < columns - 2; i++) {\n                terminal.writer().print("-");\n            }\n            terminal.writer().println("+");\n            \n            // Middle section\n            for (int i = 0; i < rows - 3; i++) {\n                terminal.writer().print("|");\n                for (int j = 0; j < columns - 2; j++) {\n                    terminal.writer().print(" ");\n                }\n                terminal.writer().println("|");\n            }\n            \n            // Bottom border\n            terminal.writer().print("+");\n            for (int i = 0; i < columns - 2; i++) {\n                terminal.writer().print("-");\n            }\n            terminal.writer().println("+");\n            \n            terminal.writer().println();\n            terminal.writer().println("Resize your terminal window and press Enter to see the new size...");\n            terminal.writer().flush();\n            \n            terminal.reader().readLine();\n            \n            // Get the updated terminal size\n            size = terminal.getSize();\n            terminal.writer().println("New terminal size:");\n            terminal.writer().println("  Columns: " + size.getColumns());\n            terminal.writer().println("  Rows: " + size.getRows());\n            terminal.writer().flush();\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"handling-size-change-events",children:"Handling Size Change Events"}),"\n",(0,t.jsx)(e.p,{children:"JLine can notify your application when the terminal size changes:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="SizeChangeHandlerExample.java" showLineNumbers',children:'import org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.Terminal.Signal;\nimport org.jline.terminal.Terminal.SignalHandler;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SizeChangeHandlerExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Clear screen\n            terminal.puts(Capability.clear_screen);\n            \n            // Display instructions\n            terminal.writer().println("Terminal Size Change Handler Example");\n            terminal.writer().println("Resize your terminal window to see the size change events.");\n            terminal.writer().println("Press Ctrl+C to exit.");\n            terminal.writer().println();\n            terminal.writer().flush();\n            \n            // Get initial size\n            Size initialSize = terminal.getSize();\n            terminal.writer().println("Initial size: " + initialSize.getColumns() + "x" + initialSize.getRows());\n            terminal.writer().flush();\n            \n            // Flag to control the main loop\n            AtomicBoolean running = new AtomicBoolean(true);\n            \n            // highlight-start\n            // Register a handler for window resize signals\n            terminal.handle(Signal.WINCH, new SignalHandler() {\n                @Override\n                public void handle(Signal signal) {\n                    // Get the new terminal size\n                    Size newSize = terminal.getSize();\n                    \n                    // Display the new size\n                    terminal.writer().println("\\nTerminal resized: " + newSize.getColumns() + "x" + newSize.getRows());\n                    \n                    // Draw a box to visualize the new size\n                    drawBox(terminal, newSize);\n                    \n                    terminal.writer().flush();\n                }\n            });\n            // highlight-end\n            \n            // Register a handler for interrupt signals (Ctrl+C)\n            terminal.handle(Signal.INT, signal -> running.set(false));\n            \n            // Main loop\n            while (running.get()) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        } finally {\n            terminal.close();\n        }\n    }\n    \n    // Helper method to draw a box\n    private static void drawBox(Terminal terminal, Size size) {\n        int columns = size.getColumns();\n        int rows = size.getRows();\n        \n        // Limit the box size to avoid filling the entire terminal\n        int boxWidth = Math.min(columns - 2, 40);\n        int boxHeight = Math.min(rows - 10, 10);\n        \n        // Draw the box\n        terminal.writer().println();\n        \n        // Top border\n        terminal.writer().print("+");\n        for (int i = 0; i < boxWidth - 2; i++) {\n            terminal.writer().print("-");\n        }\n        terminal.writer().println("+");\n        \n        // Middle section\n        for (int i = 0; i < boxHeight - 2; i++) {\n            terminal.writer().print("|");\n            for (int j = 0; j < boxWidth - 2; j++) {\n                terminal.writer().print(" ");\n            }\n            terminal.writer().println("|");\n        }\n        \n        // Bottom border\n        terminal.writer().print("+");\n        for (int i = 0; i < boxWidth - 2; i++) {\n            terminal.writer().print("-");\n        }\n        terminal.writer().println("+");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"adapting-ui-to-terminal-size",children:"Adapting UI to Terminal Size"}),"\n",(0,t.jsx)(e.p,{children:"You can adapt your UI to the terminal size to provide a better user experience:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="AdaptiveUIExample.java" showLineNumbers',children:'import org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.Terminal.Signal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedString;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class AdaptiveUIExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Clear screen\n            terminal.puts(Capability.clear_screen);\n            \n            // Display instructions\n            terminal.writer().println("Adaptive UI Example");\n            terminal.writer().println("Resize your terminal window to see the UI adapt.");\n            terminal.writer().println("Press Ctrl+C to exit.");\n            terminal.writer().println();\n            terminal.writer().flush();\n            \n            // Sample data for our UI\n            List<String[]> data = new ArrayList<>();\n            data.add(new String[]{"ID", "Name", "Email", "Role"});\n            data.add(new String[]{"1", "John Doe", "john@example.com", "Admin"});\n            data.add(new String[]{"2", "Jane Smith", "jane@example.com", "User"});\n            data.add(new String[]{"3", "Bob Johnson", "bob@example.com", "Editor"});\n            data.add(new String[]{"4", "Alice Brown", "alice@example.com", "User"});\n            data.add(new String[]{"5", "Charlie Davis", "charlie@example.com", "Viewer"});\n            \n            // Flag to control the main loop\n            AtomicBoolean running = new AtomicBoolean(true);\n            \n            // highlight-start\n            // Initial render\n            renderUI(terminal, data);\n            \n            // Register a handler for window resize signals\n            terminal.handle(Signal.WINCH, signal -> {\n                // Clear screen\n                terminal.puts(Capability.clear_screen);\n                \n                // Re-render the UI with the new terminal size\n                renderUI(terminal, data);\n            });\n            // highlight-end\n            \n            // Register a handler for interrupt signals (Ctrl+C)\n            terminal.handle(Signal.INT, signal -> running.set(false));\n            \n            // Main loop\n            while (running.get()) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        } finally {\n            terminal.close();\n        }\n    }\n    \n    // Helper method to render the UI\n    private static void renderUI(Terminal terminal, List<String[]> data) {\n        Size size = terminal.getSize();\n        int columns = size.getColumns();\n        int rows = size.getRows();\n        \n        terminal.writer().println("Terminal size: " + columns + "x" + rows);\n        terminal.writer().println();\n        \n        // Determine the layout based on terminal size\n        if (columns < 50) {\n            // Narrow terminal - use compact layout\n            renderCompactLayout(terminal, data);\n        } else {\n            // Wide terminal - use table layout\n            renderTableLayout(terminal, data, columns);\n        }\n        \n        terminal.writer().flush();\n    }\n    \n    // Render a compact layout for narrow terminals\n    private static void renderCompactLayout(Terminal terminal, List<String[]> data) {\n        terminal.writer().println("Using compact layout for narrow terminal");\n        terminal.writer().println();\n        \n        // Header\n        AttributedStringBuilder header = new AttributedStringBuilder()\n                .style(AttributedStyle.DEFAULT.bold())\n                .append("User List")\n                .style(AttributedStyle.DEFAULT);\n        header.toAttributedString().println(terminal);\n        terminal.writer().println();\n        \n        // Data\n        for (int i = 1; i < data.size(); i++) {\n            String[] row = data[i];\n            terminal.writer().println("User #" + row[0] + ":");\n            terminal.writer().println("  Name: " + row[1]);\n            terminal.writer().println("  Email: " + row[2]);\n            terminal.writer().println("  Role: " + row[3]);\n            terminal.writer().println();\n        }\n    }\n    \n    // Render a table layout for wide terminals\n    private static void renderTableLayout(Terminal terminal, List<String[]> data, int terminalWidth) {\n        terminal.writer().println("Using table layout for wide terminal");\n        terminal.writer().println();\n        \n        // Calculate column widths\n        int[] columnWidths = new int[data.get(0).length];\n        for (String[] row : data) {\n            for (int i = 0; i < row.length; i++) {\n                columnWidths[i] = Math.max(columnWidths[i], row[i].length());\n            }\n        }\n        \n        // Add padding\n        for (int i = 0; i < columnWidths.length; i++) {\n            columnWidths[i] += 2;\n        }\n        \n        // Check if table fits in terminal\n        int totalWidth = 0;\n        for (int width : columnWidths) {\n            totalWidth += width;\n        }\n        \n        // Add separators\n        totalWidth += columnWidths.length - 1;\n        \n        if (totalWidth > terminalWidth) {\n            // Table doesn\'t fit, adjust column widths\n            int excess = totalWidth - terminalWidth;\n            int columnsToAdjust = columnWidths.length;\n            int adjustmentPerColumn = excess / columnsToAdjust;\n            \n            for (int i = 0; i < columnWidths.length; i++) {\n                if (columnWidths[i] > adjustmentPerColumn + 5) {\n                    columnWidths[i] -= adjustmentPerColumn;\n                    excess -= adjustmentPerColumn;\n                }\n            }\n            \n            // If there\'s still excess, take from the widest column\n            if (excess > 0) {\n                int widestColumn = 0;\n                for (int i = 1; i < columnWidths.length; i++) {\n                    if (columnWidths[i] > columnWidths[widestColumn]) {\n                        widestColumn = i;\n                    }\n                }\n                columnWidths[widestColumn] -= excess;\n            }\n        }\n        \n        // Render header\n        String[] header = data.get(0);\n        for (int i = 0; i < header.length; i++) {\n            AttributedStringBuilder asb = new AttributedStringBuilder()\n                    .style(AttributedStyle.DEFAULT.bold())\n                    .append(padOrTruncate(header[i], columnWidths[i]));\n            asb.toAttributedString().print(terminal);\n            \n            if (i < header.length - 1) {\n                terminal.writer().print("|");\n            }\n        }\n        terminal.writer().println();\n        \n        // Render separator\n        for (int i = 0; i < header.length; i++) {\n            for (int j = 0; j < columnWidths[i]; j++) {\n                terminal.writer().print("-");\n            }\n            \n            if (i < header.length - 1) {\n                terminal.writer().print("+");\n            }\n        }\n        terminal.writer().println();\n        \n        // Render data\n        for (int rowIndex = 1; rowIndex < data.size(); rowIndex++) {\n            String[] row = data.get(rowIndex);\n            for (int i = 0; i < row.length; i++) {\n                terminal.writer().print(padOrTruncate(row[i], columnWidths[i]));\n                \n                if (i < row.length - 1) {\n                    terminal.writer().print("|");\n                }\n            }\n            terminal.writer().println();\n        }\n    }\n    \n    // Helper method to pad or truncate a string to a specific width\n    private static String padOrTruncate(String str, int width) {\n        if (str.length() > width - 1) {\n            return str.substring(0, width - 3) + ".. ";\n        } else {\n            StringBuilder sb = new StringBuilder(str);\n            while (sb.length() < width) {\n                sb.append(" ");\n            }\n            return sb.toString();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"handling-size-changes-with-linereader",children:"Handling Size Changes with LineReader"}),"\n",(0,t.jsxs)(e.p,{children:["When using ",(0,t.jsx)(e.code,{children:"LineReader"}),", you need to handle size changes to ensure proper line editing:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="LineReaderSizeChangeExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.Terminal.Signal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\n\npublic class LineReaderSizeChangeExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Clear screen\n            terminal.puts(Capability.clear_screen);\n            \n            // Create a line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .build();\n            \n            // Display instructions\n            terminal.writer().println("LineReader Size Change Example");\n            terminal.writer().println("Resize your terminal window while typing to see how LineReader adapts.");\n            terminal.writer().println();\n            \n            // highlight-start\n            // Register a handler for window resize signals\n            terminal.handle(Signal.WINCH, signal -> {\n                Size newSize = terminal.getSize();\n                terminal.writer().println("\\nTerminal resized: " + newSize.getColumns() + "x" + newSize.getRows());\n                terminal.writer().flush();\n                \n                // Redraw the line\n                reader.callWidget(LineReader.REDRAW_LINE);\n                reader.callWidget(LineReader.REDISPLAY);\n            });\n            // highlight-end\n            \n            // Read lines until "exit" is entered\n            String line;\n            while (!(line = reader.readLine("prompt> ")).equalsIgnoreCase("exit")) {\n                terminal.writer().println("You entered: " + line);\n                terminal.writer().println("Current terminal size: " + \n                        terminal.getSize().getColumns() + "x" + \n                        terminal.getSize().getRows());\n            }\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"automatic-wrapping-and-scrolling",children:"Automatic Wrapping and Scrolling"}),"\n",(0,t.jsx)(e.p,{children:"JLine handles automatic wrapping and scrolling based on the terminal size:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="WrappingAndScrollingExample.java" showLineNumbers',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.AttributedStringBuilder;\nimport org.jline.utils.AttributedStyle;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\n\npublic class WrappingAndScrollingExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Clear screen\n            terminal.puts(Capability.clear_screen);\n            \n            // Create a line reader\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(terminal)\n                    .build();\n            \n            // Display instructions\n            terminal.writer().println("Wrapping and Scrolling Example");\n            terminal.writer().println("Resize your terminal window to see how text wraps and scrolls.");\n            terminal.writer().println("Press Enter to continue...");\n            terminal.writer().flush();\n            \n            terminal.reader().readLine();\n            terminal.puts(Capability.clear_screen);\n            \n            // highlight-start\n            // Get terminal size\n            Size size = terminal.getSize();\n            int columns = size.getColumns();\n            \n            // Generate a long line that will wrap\n            StringBuilder longLine = new StringBuilder();\n            for (int i = 1; i <= 200; i++) {\n                longLine.append(i).append(" ");\n            }\n            \n            // Display the long line\n            terminal.writer().println("Long line that will wrap based on terminal width:");\n            terminal.writer().println(longLine.toString());\n            terminal.writer().println();\n            \n            // Generate text that will cause scrolling\n            terminal.writer().println("Text that will cause scrolling:");\n            for (int i = 1; i <= 50; i++) {\n                terminal.writer().println("Line " + i + " of 50");\n            }\n            // highlight-end\n            \n            terminal.writer().println();\n            terminal.writer().println("End of scrolling text. Press Enter to continue...");\n            terminal.writer().flush();\n            \n            terminal.reader().readLine();\n            terminal.puts(Capability.clear_screen);\n            \n            // Demonstrate line editing with wrapping\n            terminal.writer().println("Line editing with wrapping:");\n            terminal.writer().println("Type a long line to see how it wraps during editing.");\n            terminal.writer().println();\n            \n            String line = reader.readLine("prompt> ");\n            \n            terminal.writer().println();\n            terminal.writer().println("You entered a line of length " + line.length() + ":");\n            terminal.writer().println(line);\n        } finally {\n            terminal.close();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"minimum-size-requirements",children:"Minimum Size Requirements"}),"\n",(0,t.jsx)(e.p,{children:"You can specify minimum size requirements for your application:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",metastring:'title="MinimumSizeExample.java"',children:'import org.jline.terminal.Size;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\nimport org.jline.utils.InfoCmp.Capability;\n\nimport java.io.IOException;\n\npublic class MinimumSizeExample {\n    // highlight-start\n    // Define minimum size requirements\n    private static final int MIN_COLUMNS = 80;\n    private static final int MIN_ROWS = 24;\n    // highlight-end\n    \n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n        \n        try {\n            // Clear screen\n            terminal.puts(Capability.clear_screen);\n            \n            // Display instructions\n            terminal.writer().println("Minimum Size Requirements Example");\n            terminal.writer().println("This application requires a terminal of at least " + \n                    MIN_COLUMNS + "x" + MIN_ROWS + ".");\n            terminal.writer().println();\n            \n            // highlight-start\n            // Check if terminal meets minimum size requirements\n            Size size = terminal.getSize();\n            int columns = size.getColumns();\n            int rows = size.getRows();\n            \n            if (columns < MIN_COLUMNS || rows < MIN_ROWS) {\n                terminal.writer().println("WARNING: Terminal size is too small!");\n                terminal.writer().println("Current size: " + columns + "x" + rows);\n                terminal.writer().println("Required size: " + MIN_COLUMNS + "x" + MIN_ROWS);\n                terminal.writer().println();\n                terminal.writer().println("Please resize your terminal and press Enter to continue...");\n                terminal.writer().flush();\n                \n                terminal.reader().readLine();\n                \n                // Check again after user resized\n                size = terminal.getSize();\n                columns = size.getColumns();\n                rows = size.getRows();\n                \n                if (columns < MIN_COLUMNS || rows < MIN_ROWS) {\n                    terminal.writer().println("Terminal is still too small. Some features may not work correctly.");\n                } else {\n                    terminal.writer().println("Thank you! Terminal now meets minimum size requirements.");\n                }\n            } else {\n                terminal.writer().println("Terminal meets minimum size requirements.");\n            }\n            // highlight-end\n            \n            terminal.writer().println();\n            terminal.writer().println("Press Enter to continue...");\n            terminal.writer().flush();\n            \n            terminal.reader().readLine();\n            \n            // Display a simple UI that requires the minimum size\n            displayUI(terminal);\n        } finally {\n            terminal.close();\n        }\n    }\n    \n    // Helper method to display a UI that requires the minimum size\n    private static void displayUI(Terminal terminal) {\n        Size size = terminal.getSize();\n        int columns = size.getColumns();\n        int rows = size.getRows();\n        \n        terminal.puts(Capability.clear_screen);\n        \n        // Draw a box that requires the minimum size\n        terminal.writer().println("UI Example (requires " + MIN_COLUMNS + "x" + MIN_ROWS + "):");\n        terminal.writer().println();\n        \n        // Top border\n        terminal.writer().print("+");\n        for (int i = 0; i < MIN_COLUMNS - 2; i++) {\n            terminal.writer().print("-");\n        }\n        terminal.writer().println("+");\n        \n        // Middle section\n        for (int i = 0; i < MIN_ROWS - 4; i++) {\n            terminal.writer().print("|");\n            \n            if (i == (MIN_ROWS - 4) / 2) {\n                // Center text\n                String text = "This UI requires a " + MIN_COLUMNS + "x" + MIN_ROWS + " terminal";\n                int padding = (MIN_COLUMNS - 2 - text.length()) / 2;\n                \n                for (int j = 0; j < padding; j++) {\n                    terminal.writer().print(" ");\n                }\n                \n                terminal.writer().print(text);\n                \n                for (int j = 0; j < padding; j++) {\n                    terminal.writer().print(" ");\n                }\n                \n                // Adjust for odd lengths\n                if ((MIN_COLUMNS - 2 - text.length()) % 2 != 0) {\n                    terminal.writer().print(" ");\n                }\n            } else {\n                for (int j = 0; j < MIN_COLUMNS - 2; j++) {\n                    terminal.writer().print(" ");\n                }\n            }\n            \n            terminal.writer().println("|");\n        }\n        \n        // Bottom border\n        terminal.writer().print("+");\n        for (int i = 0; i < MIN_COLUMNS - 2; i++) {\n            terminal.writer().print("-");\n        }\n        terminal.writer().println("+");\n        \n        terminal.writer().println();\n        terminal.writer().println("Current terminal size: " + columns + "x" + rows);\n        terminal.writer().flush();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(e.p,{children:"When handling terminal size changes, consider these best practices:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Always Check Terminal Size"}),": Always check the terminal size before rendering UI elements."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Listen for Size Change Events"}),": Register a handler for the ",(0,t.jsx)(e.code,{children:"WINCH"})," signal to detect terminal size changes."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Adapt UI to Available Space"}),": Design your UI to adapt to different terminal sizes."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Provide Minimum Size Requirements"}),": Specify minimum size requirements for your application and inform users if they're not met."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Redraw After Size Changes"}),": Redraw your UI after terminal size changes to ensure proper display."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use Relative Sizing"}),": Use relative sizing (percentages) rather than absolute sizing (fixed columns/rows) when possible."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Handle Wrapping Gracefully"}),": Design your UI to handle text wrapping gracefully."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Test with Different Sizes"}),": Test your application with different terminal sizes to ensure it adapts correctly."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Consider Mobile Terminals"}),": Remember that users might be using mobile terminals with very limited screen space."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Provide Fallbacks"}),": Provide fallback layouts for terminals that are too small for your preferred layout."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>s});var r=i(6540);const t={},l=r.createContext(t);function a(n){const e=r.useContext(l);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),r.createElement(l.Provider,{value:e},n.children)}}}]);