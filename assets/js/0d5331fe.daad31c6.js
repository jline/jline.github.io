"use strict";(self.webpackChunkjline_docs=self.webpackChunkjline_docs||[]).push([[6864],{8019:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"history","title":"History Management","description":"JLine provides sophisticated history management capabilities, allowing users to recall, search, and reuse previous commands.","source":"@site/docs/history.md","sourceDirName":".","slug":"/history","permalink":"/docs/history","draft":false,"unlisted":false,"editUrl":"https://github.com/jline/jline.github.io/edit/main/docs/history.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Tab Completion","permalink":"/docs/tab-completion"},"next":{"title":"Syntax Highlighting","permalink":"/docs/advanced/syntax-highlighting"}}');var t=i(4848),a=i(8453);const s={sidebar_position:5},o="History Management",l={},d=[{value:"Basic History Setup",id:"basic-history-setup",level:2},{value:"Persistent History",id:"persistent-history",level:2},{value:"History Size",id:"history-size",level:2},{value:"History Filtering",id:"history-filtering",level:2},{value:"History Navigation",id:"history-navigation",level:2},{value:"Programmatic History Access",id:"programmatic-history-access",level:2},{value:"History Expansion",id:"history-expansion",level:2},{value:"Custom History Implementation",id:"custom-history-implementation",level:2},{value:"Advanced History Features",id:"advanced-history-features",level:2},{value:"Timestamped History",id:"timestamped-history",level:3},{value:"Searchable History",id:"searchable-history",level:3},{value:"History Event Listeners",id:"history-event-listeners",level:3},{value:"Best Practices",id:"best-practices",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"history-management",children:"History Management"})}),"\n",(0,t.jsx)(n.p,{children:"JLine provides sophisticated history management capabilities, allowing users to recall, search, and reuse previous commands."}),"\n",(0,t.jsx)(n.h2,{id:"basic-history-setup",children:"Basic History Setup"}),"\n",(0,t.jsx)(n.p,{children:"To set up history in your JLine application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistorySetupExample.java"',children:'import org.jline.reader.History;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.history.DefaultHistory;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.nio.file.Paths;\n\npublic class HistorySetupExample {\n    public static void main(String[] args) throws IOException {\n        // Create a terminal\n        Terminal terminal = TerminalBuilder.builder().build();\n\n        // highlight-start\n        // Create a history instance\n        History history = new DefaultHistory();\n\n        // Create a line reader with history\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .history(history)\n                .variable(LineReader.HISTORY_FILE, Paths.get("history.txt"))\n                .build();\n        // highlight-end\n\n        System.out.println("Type commands and use up/down arrows to navigate history");\n        // Now the user can navigate history with up/down arrows\n        String line = reader.readLine("prompt> ");\n        System.out.println("You entered: " + line);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"persistent-history",children:"Persistent History"}),"\n",(0,t.jsx)(n.p,{children:"JLine can save history to a file and load it when your application restarts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="PersistentHistoryExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.history.DefaultHistory;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.nio.file.Paths;\n\npublic class PersistentHistoryExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n\n        // highlight-start\n        // Set the history file\n        reader.setVariable(LineReader.HISTORY_FILE, Paths.get("~/.myapp_history"));\n        // highlight-end\n\n        // Use the reader...\n        String line = reader.readLine("prompt> ");\n\n        // Save history explicitly (though it\'s usually done automatically)\n        ((DefaultHistory) reader.getHistory()).save();\n\n        System.out.println("History saved to ~/.myapp_history");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"history-size",children:"History Size"}),"\n",(0,t.jsx)(n.p,{children:"You can control how many entries are kept in history:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistorySizeExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\nimport java.nio.file.Paths;\n\npublic class HistorySizeExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n\n        // highlight-start\n        // Configure history with size limits\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .variable(LineReader.HISTORY_FILE, Paths.get("~/.myapp_history"))\n                .variable(LineReader.HISTORY_SIZE, 1000)         // Maximum entries in memory\n                .variable(LineReader.HISTORY_FILE_SIZE, 2000)    // Maximum entries in file\n                .build();\n        // highlight-end\n\n        System.out.println("History configured with size limits");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"history-filtering",children:"History Filtering"}),"\n",(0,t.jsx)(n.p,{children:"JLine provides options to filter what gets added to history:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistoryFilteringExample.java" showLineNumbers',children:"import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class HistoryFilteringExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .build();\n\n        // highlight-start\n        // Don't add duplicate entries\n        reader.setOption(LineReader.Option.HISTORY_IGNORE_DUPS, true);\n\n        // Don't add entries that start with space\n        reader.setOption(LineReader.Option.HISTORY_IGNORE_SPACE, true);\n        // highlight-end\n\n        // Beep when trying to navigate past the end of history\n        reader.setOption(LineReader.Option.HISTORY_BEEP, true);\n\n        // Verify history expansion (like !!, !$, etc.)\n        reader.setOption(LineReader.Option.HISTORY_VERIFY, true);\n\n        System.out.println(\"History filtering configured\");\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"history-navigation",children:"History Navigation"}),"\n",(0,t.jsx)(n.p,{children:"Users can navigate history using:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Up/Down arrows"}),": Move through history entries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ctrl+R"}),": Reverse incremental search"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ctrl+S"}),": Forward incremental search (if supported by terminal)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alt+<"}),": Go to the first history entry"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alt+>"}),": Go to the last history entry"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"programmatic-history-access",children:"Programmatic History Access"}),"\n",(0,t.jsx)(n.p,{children:"You can access and manipulate history programmatically:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="ProgrammaticHistoryAccessExample.java"',children:'import org.jline.reader.History;\nimport org.jline.reader.LineReader;\n\npublic class ProgrammaticHistoryAccessExample {\n    public void demonstrateHistoryAccess(LineReader reader) {\n        // Get the history\n        History history = reader.getHistory();\n\n        // highlight-start\n        // Iterate through history entries\n        System.out.println("History entries:");\n        for (History.Entry entry : history) {\n            System.out.println(entry.index() + ": " + entry.line());\n        }\n        // highlight-end\n\n        // Get a specific entry\n        if (history.size() > 0) {\n            String lastCommand = history.get(history.size() - 1);\n            System.out.println("Last command: " + lastCommand);\n        }\n\n        // Add an entry programmatically\n        history.add("manually added command");\n        System.out.println("Added command to history");\n\n        // Clear history (commented out to avoid actually clearing history)\n        // history.purge();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"history-expansion",children:"History Expansion"}),"\n",(0,t.jsx)(n.p,{children:"JLine supports history expansion similar to Bash:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistoryExpansionExample.java"',children:'import org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class HistoryExpansionExample {\n    public static void main(String[] args) throws IOException {\n        Terminal terminal = TerminalBuilder.builder().build();\n\n        // highlight-start\n        // Enable history expansion\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .option(LineReader.Option.HISTORY_EXPAND, true)\n                .build();\n        // highlight-end\n\n        System.out.println("History expansion enabled. You can use:");\n        System.out.println("!! - repeat the last command");\n        System.out.println("!n - repeat command number n");\n        System.out.println("!-n - repeat nth previous command");\n        System.out.println("!string - repeat last command starting with string");\n        System.out.println("!?string - repeat last command containing string");\n        System.out.println("^string1^string2 - replace string1 with string2 in the last command");\n\n        String line = reader.readLine("prompt> ");\n        System.out.println("You entered: " + line);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"custom-history-implementation",children:"Custom History Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["You can create your own history implementation by implementing the ",(0,t.jsx)(n.code,{children:"History"})," interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="CustomHistory.java" showLineNumbers',children:"import org.jline.reader.History;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class CustomHistory implements History {\n    private final List<String> entries = new ArrayList<>();\n\n    @Override\n    public void add(String line) {\n        // highlight-start\n        // Custom logic for adding entries\n        entries.add(line);\n        // Maybe save to a database or other storage\n        // highlight-end\n    }\n\n    @Override\n    public String get(int index) {\n        return entries.get(index);\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public int index() {\n        return entries.size() - 1;\n    }\n\n    @Override\n    public Iterator<Entry> iterator() {\n        return new Iterator<Entry>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < entries.size();\n            }\n\n            @Override\n            public Entry next() {\n                final int currentIndex = index++;\n                return new Entry() {\n                    @Override\n                    public int index() {\n                        return currentIndex;\n                    }\n\n                    @Override\n                    public String line() {\n                        return entries.get(currentIndex);\n                    }\n                };\n            }\n        };\n    }\n\n    @Override\n    public void purge() {\n        entries.clear();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-history-features",children:"Advanced History Features"}),"\n",(0,t.jsx)(n.h3,{id:"timestamped-history",children:"Timestamped History"}),"\n",(0,t.jsx)(n.p,{children:"You can create a history implementation that records timestamps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="TimestampedHistory.java"',children:'import org.jline.reader.impl.history.DefaultHistory;\n\nimport java.time.Instant;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TimestampedHistory extends DefaultHistory {\n    private final Map<String, Instant> timestamps = new HashMap<>();\n\n    @Override\n    public void add(String line) {\n        // highlight-start\n        super.add(line);\n        timestamps.put(line, Instant.now());\n        // highlight-end\n    }\n\n    public Instant getTimestamp(String line) {\n        return timestamps.get(line);\n    }\n\n    public String getFormattedTimestamp(String line) {\n        Instant timestamp = timestamps.get(line);\n        if (timestamp != null) {\n            return timestamp.toString();\n        }\n        return "Unknown";\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"searchable-history",children:"Searchable History"}),"\n",(0,t.jsx)(n.p,{children:"Implement custom search functionality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistorySearchExample.java"',children:'import org.jline.reader.History;\nimport org.jline.reader.LineReader;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HistorySearchExample {\n    // highlight-start\n    public List<String> searchHistory(LineReader reader, String term) {\n        List<String> results = new ArrayList<>();\n        History history = reader.getHistory();\n\n        for (History.Entry entry : history) {\n            if (entry.line().contains(term)) {\n                results.add(entry.line());\n            }\n        }\n        // highlight-end\n\n        return results;\n    }\n\n    public void demonstrateHistorySearch(LineReader reader) {\n        System.out.println("Searching history for \'git\':");\n        List<String> gitCommands = searchHistory(reader, "git");\n\n        for (String command : gitCommands) {\n            System.out.println(" - " + command);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"history-event-listeners",children:"History Event Listeners"}),"\n",(0,t.jsx)(n.p,{children:"You can listen for history events:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'title="HistoryListenerExample.java"',children:'import org.jline.reader.History;\nimport org.jline.reader.LineReader;\nimport org.jline.reader.LineReaderBuilder;\nimport org.jline.reader.impl.history.DefaultHistory;\nimport org.jline.terminal.Terminal;\nimport org.jline.terminal.TerminalBuilder;\n\nimport java.io.IOException;\n\npublic class HistoryListenerExample {\n    public static void main(String[] args) throws IOException {\n        // highlight-start\n        // Create a history listener\n        History.Listener historyListener = new History.Listener() {\n            @Override\n            public void onAdd(History history, String line) {\n                System.out.println("Added to history: " + line);\n            }\n\n            @Override\n            public void onRemove(History history, String line) {\n                System.out.println("Removed from history: " + line);\n            }\n        };\n        // highlight-end\n\n        // Add the listener to a DefaultHistory instance\n        DefaultHistory history = new DefaultHistory();\n        history.addListener(historyListener);\n\n        Terminal terminal = TerminalBuilder.builder().build();\n        LineReader reader = LineReaderBuilder.builder()\n                .terminal(terminal)\n                .history(history)\n                .build();\n\n        System.out.println("Type commands to see history events:");\n        String line = reader.readLine("prompt> ");\n        System.out.println("You entered: " + line);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Always set a history file for persistent history"}),"\n",(0,t.jsx)(n.li,{children:"Configure appropriate history size limits"}),"\n",(0,t.jsx)(n.li,{children:"Consider enabling HISTORY_IGNORE_DUPS to avoid clutter"}),"\n",(0,t.jsx)(n.li,{children:"Provide clear documentation on history navigation for users"}),"\n",(0,t.jsx)(n.li,{children:"Consider security implications of storing sensitive commands"}),"\n",(0,t.jsx)(n.li,{children:"Implement history purging for sensitive operations"}),"\n",(0,t.jsx)(n.li,{children:"Test history functionality with various input patterns"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);